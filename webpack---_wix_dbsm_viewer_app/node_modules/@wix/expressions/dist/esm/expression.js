import {
    stylingFunctions
} from './stylingFunctions';
const array = (...args) => {
    return [...args];
};
const interpret = ({
    expression,
    functions,
    variables,
    throwIfVariableUnknown,
}) => {
    if (expression.type === 'integer') {
        return parseInt(expression.value);
    }
    if (expression.type === 'float') {
        return parseFloat(expression.value);
    }
    if (expression.type === 'string') {
        return expression.value;
    }
    if (expression.type === 'function') {
        const f = typeof expression.name === 'function' ?
            expression.name :
            functions[expression.name];
        if (f) {
            return f(...expression.arguments.map(x => interpret({
                expression: x,
                functions,
                variables,
                throwIfVariableUnknown,
            })));
        } else {
            throw new Error('Unknown function ' + expression.name);
        }
    }
    if (expression.type === 'variable') {
        if (expression.name === 'false') {
            return false;
        }
        if (expression.name === 'true') {
            return true;
        }
        if (expression.name === 'undefined') {
            return undefined;
        }
        if (expression.name === 'null') {
            return null;
        }
        if (throwIfVariableUnknown && !(expression.name in variables)) {
            throw new Error('Unknown variable ' + expression.name);
        }
        return variables[expression.name];
    }
    throw new Error('Unknown AST node ' + JSON.stringify(expression));
};
const syntaxError = (message) => new Error('Syntax error. ' + message);
const parse = (input) => {
    if (input.trim().length === 0) {
        return {
            type: 'string',
            parentFunction: undefined,
            closed: true,
            value: '',
            doubleQuoted: false,
            startedAt: 0,
        };
    }
    let state = {
        type: 'initial',
        parentFunction: undefined,
    };
    let i = 0;
    let char = input[i];
    const next = () => {
        char = input[++i];
    };
    const endArgument = (parentFunction) => {
        state = {
            type: 'initial',
            parentFunction,
        };
        next();
    };
    const isFinish = () => char === undefined ||
        (char === ')' &&
            ((state.parentFunction && !state.parentFunction.closed) ||
                (state.type === 'function' && !state.closed))) ||
        (char === ']' &&
            ((state.parentFunction &&
                    state.parentFunction.name === array &&
                    !state.parentFunction.closed) ||
                (state.type === 'function' && state.name === array && !state.closed)));
    const finish = () => {
        if (char === undefined) {
            const f = state.parentFunction || state;
            if (f.type === 'function' && !f.closed) {
                throw syntaxError('Function was not closed. Started at index ' +
                    f.startedAt +
                    ' with: ' +
                    input.slice(f.startedAt));
            }
        }
        if (state.parentFunction) {
            if (state.type === 'function' && !state.closed) {
                state.closed = true;
                state = state.parentFunction;
            } else {
                state.parentFunction.closed = true;
                state = state.parentFunction;
                if (state.parentFunction) {
                    state = state.parentFunction;
                }
            }
            next();
            return;
        }
        next();
        while (/^\s$/.test(char || '')) {
            next();
        }
        if (char !== undefined) {
            throw syntaxError('Unexpected characters after a finished expression at index ' +
                i +
                ': ' +
                input.slice(i));
        }
        return state;
    };
    while (true) {
        if (state.type === 'initial') {
            if (char === '[') {
                state = {
                    type: 'function',
                    parentFunction: state.parentFunction,
                    closed: false,
                    name: array,
                    startedAt: i,
                    arguments: [],
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char === '-') {
                state = {
                    type: 'integer',
                    parentFunction: state.parentFunction,
                    closed: false,
                    value: '-',
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char >= '0' && char <= '9') {
                state = {
                    type: 'integer',
                    parentFunction: state.parentFunction,
                    closed: false,
                    value: char,
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char === '_' ||
                (char >= 'a' && char <= 'z') ||
                (char >= 'A' && char <= 'Z')) {
                state = {
                    type: 'variable',
                    parentFunction: state.parentFunction,
                    closed: false,
                    name: char,
                    startedAt: i,
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char === '"' || char === "'") {
                state = {
                    type: 'string',
                    parentFunction: state.parentFunction,
                    closed: false,
                    doubleQuoted: char === '"',
                    startedAt: i,
                    value: '',
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (/^\s$/.test(char)) {
                next();
                continue;
            }
            throw syntaxError(`Unexpected character "${char}" near: ${input.slice(i)}`);
        } else if (state.type === 'function') {
            if (char === ',') {
                if (state.closed) {
                    throw syntaxError('Unexpected comma after a closed top-level function near: ' +
                        input.slice(i));
                }
                if (state.arguments.length === 0) {
                    // TODO
                    throw syntaxError('Function was not closed or first argument missing. Started at index ' +
                        state.startedAt +
                        ' with: ' +
                        input.slice(state.startedAt));
                }
                endArgument(state);
                continue;
            }
            if (isFinish()) {
                const returnState = finish();
                if (returnState) {
                    return returnState;
                }
                continue;
            }
            if (/^\s$/.test(char)) {
                next();
                continue;
            }
            if (state.closed) {
                throw syntaxError(`Unexpected character "${char}" near: ${input.slice(i)}`);
            }
            state = {
                type: 'initial',
                parentFunction: state,
            };
            continue;
        } else if (state.type === 'integer') {
            if (char === '.') {
                if (state.parentFunction) {
                    state.parentFunction.arguments.pop();
                }
                state = {
                    type: 'float',
                    parentFunction: state.parentFunction,
                    closed: false,
                    value: state.value + char,
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char >= '0' && char <= '9') {
                if (state.closed) {
                    throw syntaxError(`Integer has unexpected whitespace near: ${input.slice(i - 1)}`);
                }
                state.value += char;
                next();
                continue;
            }
            if (char === ',' && state.parentFunction) {
                endArgument(state.parentFunction);
                continue;
            }
            if (isFinish()) {
                const returnState = finish();
                if (returnState) {
                    return returnState;
                }
                continue;
            }
            if (/^\s$/.test(char)) {
                state.closed = true;
                next();
                continue;
            }
            throw syntaxError(`Unexpected character "${char}" after integer near: ${input.slice(i)}`);
        } else if (state.type === 'float') {
            if (char >= '0' && char <= '9') {
                if (state.closed) {
                    throw syntaxError(`Floating number has unexpected whitespace near: ${input.slice(i - 1)}`);
                }
                state.value += char;
                next();
                continue;
            }
            if (char === ',' && state.parentFunction) {
                endArgument(state.parentFunction);
                continue;
            }
            if (isFinish()) {
                const returnState = finish();
                if (returnState) {
                    return returnState;
                }
                continue;
            }
            if (/^\s$/.test(char)) {
                state.closed = true;
                next();
                continue;
            }
            throw syntaxError(`Floating number has an unexpected character "${char}" near: ${input.slice(i)}`);
        } else if (state.type === 'string') {
            if (state.closed) {
                if (char === ',' && state.parentFunction) {
                    endArgument(state.parentFunction);
                    continue;
                }
                if (isFinish()) {
                    const returnState = finish();
                    if (returnState) {
                        return returnState;
                    }
                    continue;
                }
                if (/^\s$/.test(char)) {
                    next();
                    continue;
                }
                throw syntaxError('Unexpected characters after a closed string at index ' +
                    i +
                    ': ' +
                    input.slice(i));
            } else {
                if (char === undefined) {
                    throw syntaxError(`${state.doubleQuoted ? 'Double' : 'Single'}-quoted string was not closed. Started with: ${input.slice(state.startedAt)}`);
                } else if (char === '\\') {
                    if (input[i + 1] === '\\' ||
                        input[i + 1] === '"' ||
                        input[i + 1] === "'") {
                        state.value += input[i + 1];
                        next();
                    } else {
                        throw syntaxError(`Backslash cannot escape character ${input[i + 1]} near: ${input.slice(i)}`);
                    }
                } else if ((state.doubleQuoted && char === '"') ||
                    (!state.doubleQuoted && char === "'")) {
                    state.closed = true;
                } else {
                    state.value += char;
                }
                next();
                continue;
            }
        } else if (state.type === 'variable') {
            if ((char >= '0' && char <= '9') ||
                char === '_' ||
                (char >= 'a' && char <= 'z') ||
                (char >= 'A' && char <= 'Z')) {
                if (state.closed) {
                    throw syntaxError(`Unexpected whitespace near: ${input.slice(i - 1)}`);
                }
                state.name += char;
                next();
                continue;
            }
            if (char === '(') {
                if (state.parentFunction) {
                    state.parentFunction.arguments.pop();
                }
                state = {
                    type: 'function',
                    parentFunction: state.parentFunction,
                    closed: false,
                    name: state.name,
                    startedAt: state.startedAt,
                    arguments: [],
                };
                if (state.parentFunction) {
                    state.parentFunction.arguments.push(state);
                }
                next();
                continue;
            }
            if (char === ',' && state.parentFunction) {
                endArgument(state.parentFunction);
                continue;
            }
            if (isFinish()) {
                const returnState = finish();
                if (returnState) {
                    return returnState;
                }
                continue;
            }
            if (/^\s$/.test(char)) {
                state.closed = true;
                next();
                continue;
            }
            throw syntaxError(`Unexpected character "${char}" in an identifier near: ${input.slice(i - 1)}`);
        }
    }
};
const stylingFunctionNames = Object.keys(stylingFunctions);
const hasStyling = (expression) => {
    if (expression.type === 'function') {
        if (typeof expression.name === 'string' &&
            stylingFunctionNames.includes(expression.name)) {
            return true;
        }
        return expression.arguments.some(expression => hasStyling(expression));
    }
    return false;
};
const interpretWithStyling = ({
    expression,
    functions,
    variables,
    throwIfVariableUnknown,
}) => {
    const result = interpret({
        expression,
        functions,
        variables,
        throwIfVariableUnknown,
    });
    if (!hasStyling(expression)) {
        return result;
    }
    const html = String(result);
    const alignment = expression.type === 'function' &&
        expression.name === 'ALIGN' &&
        expression.arguments[0] ?
        String(interpret({
            expression: expression.arguments[0],
            functions,
            variables,
            throwIfVariableUnknown,
        })) :
        'left';
    return {
        html,
        alignment,
    };
};
export const evaluateExpression = ({
    expression,
    functions,
    variables,
    throwIfVariableUnknown = false,
}) => interpretWithStyling({
    expression: parse(expression),
    functions,
    variables,
    throwIfVariableUnknown,
});
export const getErrorInExpression = ({
    expression,
    functions,
    variables,
}) => {
    try {
        if (functions && variables) {
            evaluateExpression({
                expression,
                functions,
                variables,
                throwIfVariableUnknown: true,
            });
        } else {
            parse(expression);
        }
        return undefined;
    } catch (error) {
        return error instanceof Error ? error.message : 'Unexpected error: ' + error;
    }
};
//# sourceMappingURL=expression.js.map