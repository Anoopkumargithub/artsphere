import {
    roleToV2,
    fieldTypeToV2,
    pluginsToV2,
    fieldPluginsToV2
} from './mappings';
import {
    deleteUndefined,
    mapIfDefined
} from './utils';
export function convertV1SchemaToV2(schema) {
    var _a;
    return deleteUndefined({
        id: schema.id,
        displayName: schema.displayName,
        displayField: schema.displayField,
        fields: toFieldsV2(schema),
        permissions: toPermissionsV2(schema),
        revision: (_a = schema.version) === null || _a === void 0 ? void 0 : _a.toString(),
        plugins: toPluginsV2(schema)
    });
}

function toPermissionsV2(schema) {
    if (!schema.permissions)
        return undefined;
    return {
        insert: roleToV2[schema.permissions.insert],
        update: roleToV2[schema.permissions.update],
        remove: roleToV2[schema.permissions.remove],
        read: roleToV2[schema.permissions.read]
    };
}

function toFieldsV2(schema) {
    var fields = Object.entries(schema.fields || {});
    return fields
        .filter(function(_a) {
            var _ = _a[0],
                field = _a[1];
            return !field.isDeleted;
        })
        .sort(function(fieldA, fieldB) {
            var _a, _b;
            var a = (_a = fieldA[1].index) !== null && _a !== void 0 ? _a : 0;
            var b = (_b = fieldB[1].index) !== null && _b !== void 0 ? _b : 0;
            if (a > b)
                return 1;
            if (a < b)
                return -1;
            if (a != null && b == null)
                return -1;
            if (a == null && b != null)
                return 1;
            return 0;
        })
        .map(function(_a) {
            var key = _a[0],
                field = _a[1];
            return toFieldV2(key, field);
        });
}

function toFieldV2(key, field) {
    function unlessAllUndef(obj) {
        return Object.values(obj).some(function(x) {
            return x !== undefined;
        }) ? obj : undefined;
    }
    return deleteUndefined({
        key: key,
        displayName: field.displayName,
        type: fieldTypeToV2[field.type],
        typeMetadata: toTypeMetadataV2(field),
        encrypted: field.pii,
        description: field.description,
        plugin: field.plugin,
        stringLengthRange: unlessAllUndef({
            minLength: field.minStrLength,
            maxLength: field.maxStrLength
        }),
        arraySizeRange: unlessAllUndef({
            minSize: field.minArraySize,
            maxSize: field.maxArraySize
        }),
        readOnly: field.readOnly,
        numberRange: unlessAllUndef({
            min: field.minValue,
            max: field.maxValue
        }),
        immutable: field.immutable,
        required: field.required,
        plugins: mapIfDefined(field.plugins, fieldPluginsToV2)
    });
}

function toTypeMetadataV2(field) {
    switch (field.type) {
        case 'pagelink':
            return toPageLinkMetadata(field);
        case 'reference':
            return toReferenceMetadata(field);
        case 'multi-reference':
            return toMultiReferenceMetadata(field);
        case 'object':
            return toObjectMetadata(field);
        case 'array':
            return toArrayMetadata(field);
    }
    return undefined;
}

function toPageLinkMetadata(field) {
    if (field.calculator == null)
        return undefined;
    if (field.calculator.config == null)
        return undefined;
    return {
        pageLink: {
            linkedRouterPage: field.linkedRouterPage,
            calculator: deleteUndefined({
                fieldsPattern: deleteUndefined({
                    pattern: field.calculator.config.pattern,
                    lowercase: field.calculator.config.lowercase
                }),
                urlizedOnlyPattern: deleteUndefined({
                    pattern: field.calculator.config.pattern
                })
            })
        }
    };
}

function toReferenceMetadata(field) {
    return {
        reference: {
            referencedCollectionId: field.referencedCollection
        }
    };
}

function toMultiReferenceMetadata(field) {
    return {
        multiReference: {
            referencedCollectionId: field.referencedCollection,
            referencingFieldKey: field.referencingFieldKey,
            referencingDisplayName: field.referencingDisplayName
        }
    };
}

function toObjectMetadata(field) {
    if (field.fields == null)
        return undefined;
    return {
        object: {
            fields: Object.entries(field.fields).map(function(_a) {
                var key = _a[0],
                    nestedField = _a[1];
                return toObjectField(key, nestedField);
            })
        }
    };
}

function toObjectField(key, nestedField) {
    return deleteUndefined({
        key: key,
        displayName: nestedField.displayName,
        type: fieldTypeToV2[nestedField.type],
        typeMetadata: toTypeMetadataV2(nestedField)
    });
}

function toArrayMetadata(field) {
    if (field.elementType == null)
        return undefined;
    return {
        array: deleteUndefined({
            elementType: fieldTypeToV2[field.elementType.type],
            typeMetadata: toTypeMetadataV2(field.elementType)
        })
    };
}

function toPluginsV2(schema) {
    var _a;
    return pluginsToV2((_a = schema.plugins) !== null && _a !== void 0 ? _a : {});
}
//# sourceMappingURL=v1-to-v2-converter.js.map