"use strict";
(("undefined" != typeof self ? self : this).webpackJsonp__wix_pro_gallery_tpa = ("undefined" != typeof self ? self : this).webpackJsonp__wix_pro_gallery_tpa || []).push([
    [731], {
        5005: (t, i, e) => {
            e.r(i), e.d(i, {
                default: () => a
            });
            var o = e(2712),
                s = e(4928),
                n = e(6219),
                r = e(8396),
                l = {
                    SCROLL: "SCROLL",
                    CLICKED: "CLICKED",
                    HOVERED: "HOVERED",
                    ENDED: "ENDED",
                    INIT_SCROLL: "INIT_SCROLL"
                };
            const a = function() {
                function t(t) {
                    var i = this;
                    this.scrollBase = 0, this.videoItems = [], this.currentPlayingIdx = -1, this.currentItemCount = 0, this.playing = !1, this.updateGalleryStructure = this.updateGalleryStructure.bind(this), this.initializePlayState = this.initializePlayState.bind(this), this.onScroll = this.onScroll.bind(this), this.handleEvent = this.handleEvent.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.isVisible = this.isVisible.bind(this), this.isCurrentVideoStillVisible = this.isCurrentVideoStillVisible.bind(this), this.videoPlay = void 0, this.itemClick = void 0, this.setPlayingVideos = t.setPlayingVideos, this.lastVideoPlayed = -1, this.videoRatingMap = new Map, this.trigger = Object.assign.apply(Object, (0, o.pr)([{}], Object.keys(l).map((function(t) {
                        var e;
                        return (e = {})[t] = function(e) {
                            return i.handleEvent({
                                eventName: t,
                                eventData: e
                            })
                        }, e
                    }))))
                }
                return t.prototype.updateGalleryStructure = function(t) {
                    var i = this,
                        e = t.galleryStructure,
                        o = t.galleryWidth,
                        s = t.scrollBase,
                        n = t.videoPlay,
                        r = t.videoLoop,
                        l = t.itemClick,
                        a = t.scrollDirection;
                    this.galleryWidth = o, this.scrollBase = s, this.videoPlay = n, this.videoLoop = r, this.itemClick = l, this.scrollDirection = a, this.currentItemCount = e.galleryItems.length, this.videoItems = [], e.galleryItems.forEach((function(t) {
                        ("video" === t.type || "image" === t.type && (t.id.includes("_placeholder") || t.isVideoPlaceholder)) && (i.videoRatingMap.has(t.id) || i.videoRatingMap.set(t.id, t.idx), i.videoItems.push(t))
                    }))
                }, t.prototype.handleEvent = function(t) {
                    var i = t.eventName,
                        e = t.eventData;
                    switch (i) {
                        case l.SCROLL:
                            this.onScroll(e);
                            break;
                        case s.Z.events.ITEM_ACTION_TRIGGERED:
                            this.itemClicked(e.idx);
                            break;
                        case s.Z.events.VIDEO_PAUSED:
                            this.currentPlayingIdx === e.idx && this.stop(e.idx);
                            break;
                        case s.Z.events.HOVER_SET:
                            this.itemHovered(e);
                            break;
                        case s.Z.events.VIDEO_ENDED:
                            this.videoEnded(e.idx);
                            break;
                        case s.Z.events.VIDEO_PLAYED:
                            this.videoPlayed(e.idx);
                            break;
                        case s.Z.events.VIDEO_ERROR:
                            this.videoErrorReported()
                    }
                }, t.prototype.itemHovered = function(t) {
                    "hover" === this.videoPlay && this.IdxExistsInVideoItems(t) && this.play(t)
                }, t.prototype.itemClicked = function(t) {
                    "onClick" === this.videoPlay && this.IdxExistsInVideoItems(t) && (this.currentPlayingIdx === t ? this.stop() : this.play(t))
                }, t.prototype.onScroll = function(t) {
                    var i = this,
                        e = t.top,
                        o = t.left;
                    this.top = e >= 0 ? e : this.top, this.left = o >= 0 ? o : this.left, -1 === this.currentPlayingIdx || this.isCurrentVideoStillVisible({
                        top: this.top,
                        left: this.left
                    }) || this.stop(this.videoItems.findIndex((function(t) {
                        return t.idx === i.currentPlayingIdx
                    }))), this.autoPlayNextVideoByRating({
                        top: this.top,
                        left: this.left
                    })
                }, t.prototype.videoEnded = function(t) {
                    var i = this.videoItems.findIndex((function(i) {
                        return i.idx === t
                    }));
                    this.stop(i);
                    var e = {
                        top: this.top,
                        left: this.left
                    };
                    this.autoPlayNextVideoByRating(e)
                }, t.prototype.videoPlayed = function(t) {
                    this.currentPlayingIdx !== t && this.play(t), this.lastVideoPlayed = t
                }, t.prototype.videoErrorReported = function() {
                    this.stop()
                }, t.prototype.initializePlayState = function() {
                    this.autoPlayNextVideoByRating({
                        top: this.top,
                        left: this.left
                    })
                }, t.prototype.autoPlayNextVideoByRating = function(t) {
                    var i = this,
                        e = t.top,
                        o = t.left;
                    if (this.shouldAutoPlay()) {
                        var s = {
                                idx: -1,
                                rating: 1 / 0
                            },
                            n = {
                                idx: -1,
                                rating: 1 / 0
                            };
                        if (this.videoItems.some((function(t) {
                                if (i.isVisible(t, {
                                        top: e,
                                        left: o
                                    })) {
                                    var r = i.videoRatingMap.get(t.id);
                                    return r <= n.rating ? (s.idx = n.idx, s.rating = n.rating, n.idx = t.idx, n.rating = r) : r <= s.rating && (s.idx = t.idx, s.rating = r), !1
                                }
                                return n.idx >= 0
                            })), n.idx >= 0)
                            if (this.allowedLoop() || n.idx !== this.lastVideoPlayed) this.play(n.idx);
                            else {
                                if (!(s.idx >= 0)) return;
                                this.play(s.idx)
                            }
                        else this.lastVideoPlayed = -2
                    }
                }, t.prototype.calculateCurrentItemPlacement = function() {
                    var t = this;
                    return this.videoItems.findIndex((function(i) {
                        return i.idx === t.currentPlayingIdx
                    }))
                }, t.prototype.play = function(t) {
                    this.setPlayingIdx(t), this.playing = !0
                }, t.prototype.stop = function(t) {
                    if (t >= 0) {
                        var i = this.videoRatingMap.get(this.videoItems[t].id) + this.currentItemCount;
                        this.videoRatingMap.set(this.videoItems[t].id, i)
                    }
                    this.setPlayingIdx(-1), this.playing = !1
                }, t.prototype.onPlayingIdxChange = function() {
                    this.setPlayingVideos(this.currentPlayingIdx)
                }, t.prototype.setPlayingIdx = function(t) {
                    this.currentPlayingIdx !== t && (this.currentPlayingIdx = t, this.onPlayingIdxChange())
                }, t.prototype.isCurrentVideoStillVisible = function(t) {
                    var i = t.top,
                        e = t.left,
                        o = this.calculateCurrentItemPlacement(),
                        s = this.videoItems[o];
                    return !!s && this.isVisible(s, {
                        top: i,
                        left: e
                    })
                }, t.prototype.isVisible = function(t, i) {
                    var e, o = i.top,
                        l = i.left,
                        a = {
                            offsetTop: this.scrollBase || 0,
                            scrollY: o,
                            scrollLeft: l
                        },
                        d = (t.offset.top - t.offset.bottom) / 2,
                        h = (t.offset.left - t.offset.right) / 2,
                        c = (0, r.ZS)({
                            target: a,
                            scrollBase: this.scrollBase,
                            top: t.offset.top,
                            bottom: t.offset.top + t.style.height,
                            screenHeight: n.Z && n.Z.innerHeight,
                            padding: d
                        });
                    return e = this.scrollDirection === s.Z.scrollDirection.VERTICAL || (0, r.qW)({
                        target: a,
                        left: t.offset.left,
                        right: t.offset.left + t.style.width,
                        screenWidth: this.galleryWidth || n.Z && n.Z.innerWidth,
                        padding: h
                    }), c && e
                }, t.prototype.shouldAutoPlay = function() {
                    return "auto" === this.videoPlay
                }, t.prototype.allowedLoop = function() {
                    return !0 === this.videoLoop
                }, t.prototype.IdxExistsInVideoItems = function(t) {
                    return this.videoItems.some((function(i) {
                        return i.idx === t
                    }))
                }, t
            }()
        },
        4272: (t, i, e) => {
            e.d(i, {
                B: () => s,
                I: () => n
            });
            var o = e(6219),
                s = function() {
                    var t = this;
                    this.promise = new Promise((function(i, e) {
                        t.reject = function() {
                            for (var i = [], o = 0; o < arguments.length; o++) i[o] = arguments[o];
                            t.isPending = !1, e.apply(void 0, i)
                        }, t.resolve = function() {
                            for (var e = [], o = 0; o < arguments.length; o++) e[o] = arguments[o];
                            t.isPending = !1, i.apply(void 0, e)
                        }, t.isPending = !0
                    }))
                };

            function n(t) {
                var i = t.container,
                    e = t.scrollTop;
                try {
                    var s = i.scrollBase < e + o.Z.innerHeight,
                        n = i.scrollBase + i.galleryHeight > e;
                    return s && n
                } catch (t) {
                    return console.warn("Could not calculate viewport", t), !0
                }
            }
        },
        3004: (t, i, e) => {
            e.d(i, {
                ZS: () => d,
                cb: () => l,
                qW: () => h,
                r1: () => u,
                rq: () => r
            });
            var o = e(3812),
                s = e(4928),
                n = e(4272);

            function r(t) {
                var i, e, n = t.scrollMarginCorrection,
                    r = void 0 === n ? 0 : n,
                    l = t.durationInMS,
                    a = t.horizontalElement,
                    d = t.scrollingElement,
                    h = t.isRTL,
                    u = t.scrollDirection,
                    p = t.galleryWidth,
                    f = t.galleryHeight,
                    y = t.totalWidth,
                    g = t.top,
                    v = t.items,
                    I = t.itemIdx,
                    m = t.fixedScroll,
                    x = t.slideTransition,
                    P = t.isContinuousScrolling,
                    E = t.autoSlideshowContinuousSpeed,
                    S = t.imageMargin,
                    b = h ? -1 : 1;
                if (u === s.Z.scrollDirection.HORIZONTAL ? (e = a.scrollLeft * b, i = e + I * p / 2) : (e = g, i = g + I * f / 2), !0 !== m) {
                    o.Z.isVerbose() && console.log("Scrolling to items #" + I);
                    var V = v.find((function(t) {
                        return t.idx === I
                    }));
                    if (i = u === s.Z.scrollDirection.HORIZONTAL ? o.Z.get(V, "offset.left") : o.Z.get(V, "offset.top"), o.Z.isVerbose() && console.log("Scrolling to position " + i, V), !(i >= 0)) return o.Z.isVerbose() && console.warn("Position not found, not scrolling"), new Promise((function(t) {
                        return t()
                    }));
                    if (u === s.Z.scrollDirection.HORIZONTAL) {
                        var C = (p - V.width - S) / 2;
                        i -= C, i = Math.max(0, i), i = Math.min(i, y - p + r), i *= b, e *= b, o.Z.isVerbose() && console.log("Scrolling to new position " + i, this)
                    }
                }
                return u === s.Z.scrollDirection.HORIZONTAL ? c({
                    scroller: a,
                    from: Math.round(e),
                    to: Math.round(i),
                    duration: l,
                    isRTL: h,
                    slideTransition: x,
                    isContinuousScrolling: P,
                    autoSlideshowContinuousSpeed: E
                }) : new Promise((function(t) {
                    d.vertical().scrollTo(0, i), t(i)
                }))
            }

            function l(t) {
                var i, e, n = t.scrollMarginCorrection,
                    r = void 0 === n ? 0 : n,
                    l = t.durationInMS,
                    a = t.horizontalElement,
                    d = t.scrollingElement,
                    h = t.isRTL,
                    u = t.scrollDirection,
                    p = t.galleryWidth,
                    f = t.galleryHeight,
                    y = t.totalWidth,
                    g = t.top,
                    v = t.groups,
                    I = t.groupIdx,
                    m = t.fixedScroll,
                    x = t.slideTransition,
                    P = t.isContinuousScrolling,
                    E = t.autoSlideshowContinuousSpeed,
                    S = t.imageMargin,
                    b = h ? -1 : 1;
                if (u === s.Z.scrollDirection.HORIZONTAL ? (e = a.scrollLeft, i = e + I * p / 2) : (e = g, i = g + I * f / 2), !0 !== m) {
                    o.Z.isVerbose() && console.log("Scrolling to groups #" + I);
                    var V = v.find((function(t) {
                        return t.idx === I
                    }));
                    if (i = u === s.Z.scrollDirection.HORIZONTAL ? o.Z.get(V, "left") : o.Z.get(V, "top"), o.Z.isVerbose() && console.log("Scrolling to position " + i, V), !(i >= 0)) return o.Z.isVerbose() && console.warn("Position not found, not scrolling"), new Promise((function(t) {
                        return t()
                    }));
                    if (u === s.Z.scrollDirection.HORIZONTAL) {
                        var C = (p - V.width - S) / 2;
                        i -= C, i = Math.max(0, i), i = Math.min(i, y - p + r), i *= b, o.Z.isVerbose() && console.log("Scrolling to new position " + i, this)
                    }
                }
                return u === s.Z.scrollDirection.HORIZONTAL ? c({
                    scroller: a,
                    from: Math.round(e),
                    to: Math.round(i),
                    duration: l,
                    isRTL: h,
                    slideTransition: x,
                    isContinuousScrolling: P,
                    autoSlideshowContinuousSpeed: E
                }) : new Promise((function(t) {
                    d.vertical().scrollTo(0, i), t(i)
                }))
            }

            function a(t) {
                var i = t.offset,
                    e = t.scroll,
                    o = t.itemStart;
                return {
                    before: e - i - t.itemEnd,
                    after: i + o - t.screenSize - e
                }
            }

            function d(t) {
                var i = t.target,
                    e = t.scrollBase,
                    o = t.top,
                    s = t.bottom,
                    n = t.screenHeight,
                    r = t.padding,
                    l = a({
                        offset: e || 0,
                        scroll: i.scrollY,
                        itemStart: o,
                        itemEnd: s,
                        screenSize: n
                    });
                return l.before < r && l.after < r
            }

            function h(t) {
                var i = t.target,
                    e = t.left,
                    o = t.right,
                    s = t.screenWidth,
                    n = t.padding,
                    r = a({
                        offset: 0,
                        scroll: i.scrollLeft,
                        itemStart: e,
                        itemEnd: o,
                        screenSize: s
                    });
                return r.before < n && r.after < n
            }

            function c(t) {
                var i = t.scroller,
                    e = t.from,
                    o = t.to,
                    s = t.duration,
                    r = t.isRTL,
                    l = t.slideTransition,
                    a = t.isContinuousScrolling,
                    d = t.autoSlideshowContinuousSpeed,
                    h = o - e;
                if (0 === h) return new Promise((function(t) {
                    return t(o)
                }));
                a && (s = Math.abs(h) / d * 1e3);
                var c = i.firstChild;
                i.setAttribute("data-scrolling", "true"), Object.assign(i.style, {
                    "scroll-snap-type": "none"
                }), Object.assign(c.style, {
                    transition: "transform " + s + "ms " + l,
                    "-webkit-transition": "transform " + s + "ms " + l
                }, {
                    transform: "translateX(" + -1 * h + "px)"
                });
                var u = new CustomEvent("scrollTransition", {
                        detail: h / 10
                    }),
                    p = setInterval((function() {
                        i.dispatchEvent(u)
                    }), Math.round(s / 10)),
                    f = new n.B,
                    y = setTimeout((function() {
                        clearInterval(p), Object.assign(c.style, {
                            transition: "none",
                            "-webkit-transition": "none"
                        }, {
                            transform: "translateX(0px)"
                        }), i.style.removeProperty("scroll-snap-type"), i.scrollLeft = o, i.setAttribute("data-scrolling", ""), f.resolve(o)
                    }), s);
                return {
                    scrollDeffered: f,
                    scroller: i,
                    from: e,
                    to: o,
                    duration: s,
                    isRTL: r,
                    slideTransition: l,
                    isContinuousScrolling: a,
                    autoSlideshowContinuousSpeed: d,
                    currentScrollEndTimeout: y
                }
            }

            function u(t) {
                var i = t.scroller,
                    e = t.from,
                    o = t.isRTL,
                    s = t.currentScrollEndTimeout,
                    r = t.scrollDeffered;
                clearTimeout(s);
                var l = i.firstChild,
                    a = getComputedStyle(l).getPropertyValue("transform"),
                    d = new DOMMatrix(a);
                (function(t) {
                    var i = t.scroller,
                        e = t.at,
                        o = t.isRTL;
                    Object.assign(i.style, {
                        "scroll-snap-type": "none"
                    });
                    var s = new n.B;
                    Object.assign(i.firstChild.style, {
                        transition: "none",
                        "-webkit-transition": "none"
                    }, {
                        transform: "translateX(0px)"
                    }), i.scrollLeft = e, s.resolve(e)
                })({
                    scroller: i,
                    at: e -= Math.round(parseInt(d.m41, 10)),
                    isRTL: o
                }), r.resolve(e)
            }
        },
        7160: (t, i, e) => {
            e.r(i), e.d(i, {
                default: () => a
            });
            var o = e(2712),
                s = e(4928),
                n = e(6219),
                r = e(3004),
                l = {
                    SCROLL: "SCROLL",
                    CLICKED: "CLICKED",
                    HOVERED: "HOVERED",
                    ENDED: "ENDED",
                    INIT_SCROLL: "INIT_SCROLL"
                };
            const a = function() {
                function t(t) {
                    var i = this;
                    this.scrollBase = 0, this.videoItems = [], this.currentPlayingIdx = -1, this.currentItemCount = 0, this.playing = !1, this.updateGalleryStructure = this.updateGalleryStructure.bind(this), this.initializePlayState = this.initializePlayState.bind(this), this.onScroll = this.onScroll.bind(this), this.handleEvent = this.handleEvent.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.isVisible = this.isVisible.bind(this), this.isCurrentVideoStillVisible = this.isCurrentVideoStillVisible.bind(this), this.videoPlay = void 0, this.itemClick = void 0, this.setPlayingVideos = t.setPlayingVideos, this.lastVideoPlayed = -1, this.videoRatingMap = new Map, this.trigger = Object.assign.apply(Object, (0, o.pr)([{}], Object.keys(l).map((function(t) {
                        var e;
                        return (e = {})[t] = function(e) {
                            return i.handleEvent({
                                eventName: t,
                                eventData: e
                            })
                        }, e
                    }))))
                }
                return t.prototype.updateGalleryStructure = function(t) {
                    var i = this,
                        e = t.galleryStructure,
                        o = t.galleryWidth,
                        s = t.scrollBase,
                        n = t.videoPlay,
                        r = t.videoLoop,
                        l = t.itemClick,
                        a = t.scrollDirection;
                    this.galleryWidth = o, this.scrollBase = s, this.videoPlay = n, this.videoLoop = r, this.itemClick = l, this.scrollDirection = a, this.currentItemCount = e.galleryItems.length, this.videoItems = [], e.galleryItems.forEach((function(t) {
                        ("video" === t.type || "image" === t.type && (t.id.includes("_placeholder") || t.isVideoPlaceholder)) && (i.videoRatingMap.has(t.id) || i.videoRatingMap.set(t.id, t.idx), i.videoItems.push(t))
                    }))
                }, t.prototype.handleEvent = function(t) {
                    var i = t.eventName,
                        e = t.eventData;
                    switch (i) {
                        case l.SCROLL:
                            this.onScroll(e);
                            break;
                        case s.Z.events.ITEM_ACTION_TRIGGERED:
                            this.itemClicked(e.idx);
                            break;
                        case s.Z.events.VIDEO_PAUSED:
                            this.currentPlayingIdx === e.idx && this.stop(e.idx);
                            break;
                        case s.Z.events.HOVER_SET:
                            this.itemHovered(e);
                            break;
                        case s.Z.events.VIDEO_ENDED:
                            this.videoEnded(e.idx);
                            break;
                        case s.Z.events.VIDEO_PLAYED:
                            this.videoPlayed(e.idx);
                            break;
                        case s.Z.events.VIDEO_ERROR:
                            this.videoErrorReported()
                    }
                }, t.prototype.itemHovered = function(t) {
                    "hover" === this.videoPlay && this.IdxExistsInVideoItems(t) && this.play(t)
                }, t.prototype.itemClicked = function(t) {
                    "onClick" === this.videoPlay && this.IdxExistsInVideoItems(t) && (this.currentPlayingIdx === t ? this.stop() : this.play(t))
                }, t.prototype.onScroll = function(t) {
                    var i = this,
                        e = t.top,
                        o = t.left;
                    this.top = e >= 0 ? e : this.top, this.left = o >= 0 ? o : this.left, -1 === this.currentPlayingIdx || this.isCurrentVideoStillVisible({
                        top: this.top,
                        left: this.left
                    }) || this.stop(this.videoItems.findIndex((function(t) {
                        return t.idx === i.currentPlayingIdx
                    }))), this.autoPlayNextVideoByRating({
                        top: this.top,
                        left: this.left
                    })
                }, t.prototype.videoEnded = function(t) {
                    var i = this.videoItems.findIndex((function(i) {
                        return i.idx === t
                    }));
                    this.stop(i);
                    var e = {
                        top: this.top,
                        left: this.left
                    };
                    this.autoPlayNextVideoByRating(e)
                }, t.prototype.videoPlayed = function(t) {
                    this.currentPlayingIdx !== t && this.play(t), this.lastVideoPlayed = t
                }, t.prototype.videoErrorReported = function() {
                    this.stop()
                }, t.prototype.initializePlayState = function() {
                    this.autoPlayNextVideoByRating({
                        top: this.top,
                        left: this.left
                    })
                }, t.prototype.autoPlayNextVideoByRating = function(t) {
                    var i = this,
                        e = t.top,
                        o = t.left;
                    if (this.shouldAutoPlay()) {
                        var s = {
                                idx: -1,
                                rating: 1 / 0
                            },
                            n = {
                                idx: -1,
                                rating: 1 / 0
                            };
                        if (this.videoItems.some((function(t) {
                                if (i.isVisible(t, {
                                        top: e,
                                        left: o
                                    })) {
                                    var r = i.videoRatingMap.get(t.id);
                                    return r <= n.rating ? (s.idx = n.idx, s.rating = n.rating, n.idx = t.idx, n.rating = r) : r <= s.rating && (s.idx = t.idx, s.rating = r), !1
                                }
                                return n.idx >= 0
                            })), n.idx >= 0)
                            if (this.allowedLoop() || n.idx !== this.lastVideoPlayed) this.play(n.idx);
                            else {
                                if (!(s.idx >= 0)) return;
                                this.play(s.idx)
                            }
                        else this.lastVideoPlayed = -2
                    }
                }, t.prototype.calculateCurrentItemPlacement = function() {
                    var t = this;
                    return this.videoItems.findIndex((function(i) {
                        return i.idx === t.currentPlayingIdx
                    }))
                }, t.prototype.play = function(t) {
                    this.setPlayingIdx(t), this.playing = !0
                }, t.prototype.stop = function(t) {
                    if (t >= 0) {
                        var i = this.videoRatingMap.get(this.videoItems[t].id) + this.currentItemCount;
                        this.videoRatingMap.set(this.videoItems[t].id, i)
                    }
                    this.setPlayingIdx(-1), this.playing = !1
                }, t.prototype.onPlayingIdxChange = function() {
                    this.setPlayingVideos(this.currentPlayingIdx)
                }, t.prototype.setPlayingIdx = function(t) {
                    this.currentPlayingIdx !== t && (this.currentPlayingIdx = t, this.onPlayingIdxChange())
                }, t.prototype.isCurrentVideoStillVisible = function(t) {
                    var i = t.top,
                        e = t.left,
                        o = this.calculateCurrentItemPlacement(),
                        s = this.videoItems[o];
                    return !!s && this.isVisible(s, {
                        top: i,
                        left: e
                    })
                }, t.prototype.isVisible = function(t, i) {
                    var e, o = i.top,
                        l = i.left,
                        a = {
                            offsetTop: this.scrollBase || 0,
                            scrollY: o,
                            scrollLeft: l
                        },
                        d = (t.offset.top - t.offset.bottom) / 2,
                        h = (t.offset.left - t.offset.right) / 2,
                        c = (0, r.ZS)({
                            target: a,
                            scrollBase: this.scrollBase,
                            top: t.offset.top,
                            bottom: t.offset.top + t.style.height,
                            screenHeight: n.Z && n.Z.innerHeight,
                            padding: d
                        });
                    return e = this.scrollDirection === s.Z.scrollDirection.VERTICAL || (0, r.qW)({
                        target: a,
                        left: t.offset.left,
                        right: t.offset.left + t.style.width,
                        screenWidth: this.galleryWidth || n.Z && n.Z.innerWidth,
                        padding: h
                    }), c && e
                }, t.prototype.shouldAutoPlay = function() {
                    return "auto" === this.videoPlay
                }, t.prototype.allowedLoop = function() {
                    return !0 === this.videoLoop
                }, t.prototype.IdxExistsInVideoItems = function(t) {
                    return this.videoItems.some((function(i) {
                        return i.idx === t
                    }))
                }, t
            }()
        }
    }
]);
//# sourceMappingURL=proGallery_videoScrollHelper.chunk.min.js.map