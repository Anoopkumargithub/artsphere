(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [4600], {
        61916: function(e) {
            "use strict";

            function t(e) {
                return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, t(e)
            }
            var r = "User",
                i = "Error",
                n = "EDM",
                s = function(e, r) {
                    e && "object" === t(e) && (e.errorGroup = r)
                };
            e.exports = {
                markUserError: function(e) {
                    return s(e, r)
                },
                isUserError: function(e) {
                    return e && e.errorGroup === r
                },
                markAppError: function(e) {
                    return s(e, i)
                },
                isAppError: function(e) {
                    return e && e.errorGroup === i
                },
                markEdmError: function(e) {
                    return s(e, n)
                },
                isEdmError: function(e) {
                    return e && e.errorGroup === n
                },
                markError: s,
                isMarked: function(e) {
                    return !!e && void 0 !== e.errorGroup
                },
                USER_ERROR_GROUP: r,
                APP_ERROR_GROUP: i,
                EDM_ERROR_GROUP: n,
                UNKNOWN_ERROR_GROUP: "Unknown"
            }
        },
        50470: function(e, t, r) {
            "use strict";

            function i(e) {
                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, i(e)
            }

            function n(e, t) {
                for (var r = 0; r < t.length; r++) {
                    var i = t[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            function s(e, t) {
                return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                }, s(e, t)
            }

            function o(e) {
                var t = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function() {
                    var r, n = l(e);
                    if (t) {
                        var s = l(this).constructor;
                        r = Reflect.construct(n, arguments, s)
                    } else r = n.apply(this, arguments);
                    return function(e, t) {
                        if (t && ("object" === i(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return a(e)
                    }(this, r)
                }
            }

            function a(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function l(e) {
                return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, l(e)
            }
            var c = r(61916),
                u = function(e) {
                    ! function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && s(e, t)
                    }(u, e);
                    var t, r, i, l = o(u);

                    function u() {
                        var e;
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, u);
                        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
                        return e = l.call.apply(l, [this].concat(r)), Error.captureStackTrace && Error.captureStackTrace(a(e), e.constructor), e.name = u.name, c.markUserError(a(e)), e
                    }
                    return t = u, r && n(t.prototype, r), i && n(t, i), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }(function(e) {
                    function t() {
                        var t = Reflect.construct(e, Array.from(arguments));
                        return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), t
                    }
                    return t.prototype = Object.create(e.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t
                }(Error));
            e.exports = {
                UserCodeError: u
            }
        },
        62673: function(e, t, r) {
            "use strict";

            function i(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    t && (i = i.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), r.push.apply(r, i)
                }
                return r
            }

            function n(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? i(Object(r), !0).forEach((function(t) {
                        s(e, t, r[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    }))
                }
                return e
            }

            function s(e, t, r) {
                return t in e ? Object.defineProperty(e, t, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = r, e
            }
            var o = r(61916),
                a = r(50470);
            e.exports = n(n({}, a), o)
        },
        69012: function(e) {
            var t = Object.prototype.toString;
            e.exports = function(e) {
                var r = typeof e;
                return "undefined" === r ? "undefined" : null === e ? "null" : !0 === e || !1 === e || e instanceof Boolean ? "boolean" : "string" === r || e instanceof String ? "string" : "number" === r || e instanceof Number ? "number" : "function" === r || e instanceof Function ? void 0 !== e.constructor.name && "Generator" === e.constructor.name.slice(0, 9) ? "generatorfunction" : "function" : void 0 !== Array.isArray && Array.isArray(e) ? "array" : e instanceof RegExp ? "regexp" : e instanceof Date ? "date" : "[object RegExp]" === (r = t.call(e)) ? "regexp" : "[object Date]" === r ? "date" : "[object Arguments]" === r ? "arguments" : "[object Error]" === r ? "error" : "[object Promise]" === r ? "promise" : function(e) {
                    return e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
                }(e) ? "buffer" : "[object Set]" === r ? "set" : "[object WeakSet]" === r ? "weakset" : "[object Map]" === r ? "map" : "[object WeakMap]" === r ? "weakmap" : "[object Symbol]" === r ? "symbol" : "[object Map Iterator]" === r ? "mapiterator" : "[object Set Iterator]" === r ? "setiterator" : "[object String Iterator]" === r ? "stringiterator" : "[object Array Iterator]" === r ? "arrayiterator" : "[object Int8Array]" === r ? "int8array" : "[object Uint8Array]" === r ? "uint8array" : "[object Uint8ClampedArray]" === r ? "uint8clampedarray" : "[object Int16Array]" === r ? "int16array" : "[object Uint16Array]" === r ? "uint16array" : "[object Int32Array]" === r ? "int32array" : "[object Uint32Array]" === r ? "uint32array" : "[object Float32Array]" === r ? "float32array" : "[object Float64Array]" === r ? "float64array" : "object"
            }
        },
        88794: function(e, t, r) {
            "use strict";
            r.r(t), r.d(t, {
                clone: function() {
                    return g
                },
                extractForwardHeaders: function() {
                    return w
                },
                getSchemaName: function() {
                    return j
                },
                getSchemaNamespace: function() {
                    return $
                },
                isArray: function() {
                    return o
                },
                isBoolean: function() {
                    return c
                },
                isDate: function() {
                    return a
                },
                isFunction: function() {
                    return d
                },
                isNull: function() {
                    return m
                },
                isNumber: function() {
                    return l
                },
                isObject: function() {
                    return s
                },
                isString: function() {
                    return u
                },
                isUndefined: function() {
                    return p
                },
                parseDates: function() {
                    return _
                },
                parseEntityJson: function() {
                    return y
                },
                parseSchemaId: function() {
                    return O
                },
                serializeDates: function() {
                    return N
                },
                stringifyEntityJson: function() {
                    return I
                },
                toPlatformizedAggregate: function() {
                    return S
                },
                typeForDisplay: function() {
                    return h
                },
                validateHttpResponse: function() {
                    return D
                }
            });
            var i = r(83301),
                n = r.n(i);

            function s(e) {
                return "object" === n()(e)
            }

            function o(e) {
                return "array" === n()(e)
            }

            function a(e) {
                return "date" === n()(e)
            }

            function l(e) {
                return "number" === n()(e)
            }

            function c(e) {
                return "boolean" === n()(e)
            }

            function u(e) {
                return "string" === n()(e)
            }

            function d(e) {
                return "function" === n()(e)
            }

            function h(e) {
                return function(e) {
                    if (!u(e)) return e;
                    const t = e.slice(0, 1).toUpperCase(),
                        r = e.slice(1, e.length);
                    return t + r
                }(n()(e))
            }

            function p(e) {
                return "undefined" === n()(e)
            }

            function m(e) {
                return "null" === n()(e)
            }

            function g(e) {
                if (null == e || "object" != typeof e) return e;
                let t = null;
                if (a(e)) t = new Date(e.getTime());
                else {
                    t = e.constructor();
                    for (const r in e) t[r] = g(e[r])
                }
                return t
            }

            function f(e) {
                return "[object Date]" === Object.prototype.toString.call(e) && !isNaN(e.getTime())
            }
            const v = e => isNaN(e) && !isNaN(new Date(e).getDate());

            function y(e) {
                let t = null;
                return JSON.parse(e, (function(e, r) {
                    if ("$date" === e && v(r)) t = new Date(r);
                    else {
                        if ("$date" !== e) {
                            if (null !== t) {
                                const e = t;
                                return t = null, e
                            }
                            return r
                        }
                        t = {
                            $date: r
                        }
                    }
                }))
            }

            function _(e) {
                if ("object" != typeof e || f(e)) return e;
                const t = A(e);
                for (const e in t) t[e] && t[e].$date && v(t[e].$date) ? t[e] = new Date(t[e].$date) : "object" == typeof t[e] && null !== t[e] && (t[e] = _(t[e]));
                return t
            }

            function N(e) {
                if ("object" != typeof e || f(e)) return e;
                const t = A(e);
                for (const e in t) t[e] && f(t[e]) ? t[e] = b(t[e]) : "object" == typeof t[e] && null !== t[e] && (t[e] = N(t[e]));
                return t
            }

            function I(e) {
                return JSON.stringify(e, (function(e, t) {
                    return function(e, t, r) {
                        if (t && f(e[t])) return b(e[t]);
                        return r
                    }(this, e, t)
                }))
            }

            function b(e) {
                return {
                    $date: e.toJSON()
                }
            }

            function A(e) {
                return Array.isArray(e) ? Object.assign([], e) : { ...e
                }
            }

            function S(e) {
                return e.reduce(((e, t, r) => {
                    const [i, n] = Object.entries(t)[0];
                    return "$match" === i && 0 === r ? {
                        preFilteringStep: n
                    } : "$match" === i ? { ...e,
                        postFilteringStep: n
                    } : "$group" === i ? { ...e,
                        processingStep: n
                    } : e
                }), {})
            }

            function $(e) {
                const t = e.lastIndexOf("/");
                return t > -1 ? e.substring(0, t) : null
            }

            function j(e) {
                const t = e.lastIndexOf("/");
                return t > -1 ? e.substring(t + 1) : e
            }

            function O(e) {
                return {
                    namespace: $(e),
                    name: j(e)
                }
            }

            function w({
                headers: e = {},
                query: t = {}
            }) {
                const r = ["uuid", "cid", "authorization", "wixsession2", "cookie"],
                    i = {};
                for (const t in e) {
                    const s = t.toLowerCase();
                    e.hasOwnProperty(t) && (0 === (n = s).indexOf("x-wix") || r.includes(n)) && (i[s] = e[t])
                }
                var n;
                const s = "x-wix-request-id",
                    o = "request_id";
                return t && t[o] && (i[s] || (i[s] = t[o])), i
            }

            function D(e) {
                if (e.status >= 400) {
                    const t = JSON.stringify(e.data),
                        r = new Error(`Request failed with status code ${e.status}. Data: '${t}'.`);
                    throw r.response = e, r.config = e.config, r.request = e.request, r
                }
                return e
            }
        },
        83301: function(e) {
            var t = Object.prototype.toString;
            e.exports = function(e) {
                var r = typeof e;
                return "undefined" === r ? "undefined" : null === e ? "null" : !0 === e || !1 === e || e instanceof Boolean ? "boolean" : "string" === r || e instanceof String ? "string" : "number" === r || e instanceof Number ? "number" : "function" === r || e instanceof Function ? void 0 !== e.constructor.name && "Generator" === e.constructor.name.slice(0, 9) ? "generatorfunction" : "function" : void 0 !== Array.isArray && Array.isArray(e) ? "array" : e instanceof RegExp ? "regexp" : e instanceof Date ? "date" : "[object RegExp]" === (r = t.call(e)) ? "regexp" : "[object Date]" === r ? "date" : "[object Arguments]" === r ? "arguments" : "[object Error]" === r ? "error" : "[object Promise]" === r ? "promise" : function(e) {
                    return e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
                }(e) ? "buffer" : "[object Set]" === r ? "set" : "[object WeakSet]" === r ? "weakset" : "[object Map]" === r ? "map" : "[object WeakMap]" === r ? "weakmap" : "[object Symbol]" === r ? "symbol" : "[object Map Iterator]" === r ? "mapiterator" : "[object Set Iterator]" === r ? "setiterator" : "[object String Iterator]" === r ? "stringiterator" : "[object Array Iterator]" === r ? "arrayiterator" : "[object Int8Array]" === r ? "int8array" : "[object Uint8Array]" === r ? "uint8array" : "[object Uint8ClampedArray]" === r ? "uint8clampedarray" : "[object Int16Array]" === r ? "int16array" : "[object Uint16Array]" === r ? "uint16array" : "[object Int32Array]" === r ? "int32array" : "[object Uint32Array]" === r ? "uint32array" : "[object Float32Array]" === r ? "float32array" : "[object Float64Array]" === r ? "float64array" : "object"
            }
        },
        37511: function(e) {
            var t = Object.prototype.hasOwnProperty;

            function r(e) {
                return "[Throws: " + (e ? e.message : "?") + "]"
            }

            function i(e) {
                var i = [];
                return function e(n) {
                    if (null === n || "object" != typeof n) return n;
                    if (-1 !== i.indexOf(n)) return "[Circular]";
                    if (i.push(n), "function" == typeof n.toJSON) try {
                        var s = e(n.toJSON());
                        return i.pop(), s
                    } catch (e) {
                        return r(e)
                    }
                    if (Array.isArray(n)) {
                        var o = n.map(e);
                        return i.pop(), o
                    }
                    var a = Object.keys(n).reduce((function(i, s) {
                        return i[s] = e(function(e, i) {
                            if (t.call(e, i)) try {
                                return e[i]
                            } catch (e) {
                                return r(e)
                            }
                            return e[i]
                        }(n, s)), i
                    }), {});
                    return i.pop(), a
                }(e)
            }
            e.exports = function(e, t, r) {
                return JSON.stringify(i(e), t, r)
            }, e.exports.ensureProperties = i
        },
        28041: function(e, t, r) {
            "use strict";
            r.d(t, {
                DataSdkFactory: function() {
                    return ut
                }
            });
            var i = r(88794),
                n = r(62673),
                s = r(37511),
                o = r.n(s);

            function a(e) {
                return o()(e)
            }
            const l = () => "WDE0001: Collection name must be a string.",
                c = () => "WDE0002: ItemId must be a string.",
                u = () => "WDE0068: Item ids must be an array of strings",
                d = e => `WDE0069: Failed to remove items from [${e}].\nCannot remove more than 1000 items in one request`,
                h = () => "WDE0003: FieldName must be a string.",
                p = (e, t) => `WDE0004: Failed to save [${e}] into [${t}].\nItems must be JavaScript objects.`,
                m = e => `WDE0005: Failed to bulk save items into [${e}].\nItems must be an array of JavaScript objects and itemIds must be strings if present.`,
                g = e => `WDE0006: Failed to bulk save items into [${e}].\nCannot insert more than 1000 items in one request`,
                f = () => "WDE0007: Invalid update. Updated object must have a string _id property.",
                v = (e, t, r, i) => `WDE0008: wixData.${e} expects between ${t} and ${r} arguments, but was called with ${i}.`,
                y = {
                    aggregateInvalid: (e, t) => `Failed to perform aggregation on [${e}].\n${t.join("\n")}`,
                    filterMustBeBuilder: e => `WDE0011: Invalid ${e} usage. ${e} requires WixDataFilter.`,
                    filterIsAlreadySet: e => `WDE0012: Invalid ${e} usage. Filter is already set.`,
                    groupIsAlreadySet: e => `WDE0013: Invalid ${e} usage. Group is already set.`
                },
                _ = e => `Failed to build a filter.\n${e.join("\n")}.`,
                N = e => `Failed to build group.\n${e.join("\n")}.`,
                I = e => `Failed to build a sort.\n${e.join("\n")}.`,
                b = e => `WDE0018: Options must be an object with one or all of the following boolean properties: ${e.join(", ")}.`,
                A = () => "WDE0019: Reference operation takes a string ID or an object with an ID to be connected.",
                S = () => "WDE0021: Invalid reference",
                $ = {
                    queryInvalid: (e, t) => `Failed to perform query on [${e}].\n${t.join("\n")}`,
                    isNumber: (e, t, r) => `WDE0032: Invalid ${e} parameter [${(0,i.typeForDisplay)(r)}]. ${e} parameter must be a ${t} number.`,
                    isPositiveNumber: (e, t) => `WDE0033: Invalid ${e} parameter [${t}]. ${e} parameter must be a positive number.`,
                    isNonNegativeNumber: (e, t) => `WDE0034: Invalid ${e} parameter [${t}]. ${e} parameter must be a non-negative number.`,
                    isInteger: (e, t) => `WDE0035: Invalid ${e} parameter [${t}]. ${e} parameter must be an integer.`,
                    isNonEmptyString: e => `WDE0094: Invalid ${e} parameter. ${e} parameter must be non-empty string.`,
                    notGreaterThan: (e, t, r) => `WDE0036: Invalid ${e} parameter [${t}]. ${e} parameter cannot exceed ${r}.`,
                    invalidSkipParameter: (e, t) => `WDE0037: Invalid query on [${e}].\nInvalid prev positioned query skip on a negative number ${t}.`,
                    noPrevPage: e => `WDE0159: Invalid query on [${e}].\nThere is no prev page.`,
                    noNextPage: e => `WDE0165: Invalid query on [${e}].\nThere is no next page.`
                },
                j = {
                    arityIsZero: e => `WDE0038: Invalid ${e} usage. ${e} does not take parameters.`,
                    arityIsOne: e => `WDE0039: Invalid ${e} usage. ${e} requires one parameter.`,
                    arityIsTwo: e => `WDE0040: Invalid ${e} usage. ${e} requires two parameters.`,
                    arityIsThree: e => `WDE0041: Invalid ${e} usage. ${e} requires three parameters.`,
                    arityIsAtLeastTwo: e => `WDE0042: Invalid ${e} usage. ${e} requires at least two parameters.`,
                    arityIsAtLeastOne: e => `WDE0043: Invalid ${e} usage. ${e} requires at least one parameter.`
                },
                O = {
                    typeIsString: (e, t) => `WDE0044: Invalid ${e} parameter value [${(0,i.typeForDisplay)(t)}]. ${e} parameter must be a String.`,
                    typeIsStringNumberOrDate: (e, t) => `WDE0045: Invalid ${e} parameter value [${(0,i.typeForDisplay)(t)}]. Valid ${e} parameter types are String, Number or Date.`,
                    sameType: (e, t, r) => `WDE0046: Invalid ${e} parameter values [${(0,i.typeForDisplay)(t)}] and [${(0,i.typeForDisplay)(r)}]. Both parameters must be of the same type.`,
                    typeIsStringNumberOrDateForAll: e => `WDE0047: Invalid ${e} usage. ${e} supports only Number, String or Date items.`,
                    validFieldName: (e, t) => `WDE0048: Invalid ${e} field value [${(0,i.typeForDisplay)(t)}]. ${e} field must be a String.`,
                    isInstanceOfSameClass: (e, t, r) => `WDE0049: Invalid ${e} parameter [${(0,i.typeForDisplay)(r)}]. ${e} expects ${t} only.`,
                    isForCollection: (e, t, r) => `WDE0050: Invalid ${e} parameter query for [${r}]. ${e} accepts ${t} for the same collection only.`,
                    incorrectDraftPublishFilter: () => "WDE0093: Invalid filter for _publishStatus field, only .eq and .ne filters are allowed with 'DRAFT' and 'PUBLISHED' possible values."
                },
                w = {
                    objectType: (e, t) => `WDE0056: ${e} should be an Object. Got ${a(t)} instead`,
                    arrayType: (e, t) => `WDE0057: ${e} should be an Array. Got ${a(t)} instead`,
                    arrayLength: (e, t, r) => `WDE0057: ${a(r)}.length is ${r.length}. ${e} Array should have length ${t}`,
                    comparisonOperatorType: (e, t) => `WDE0058: ${e} should be a Date, Number, or String. Got ${a(t)} instead`,
                    stringOperatorType: (e, t) => `WDE0059: ${e} should be a String. Got ${a(t)} instead`,
                    setOperatorItems: (e, t) => `WDE0060: ${e} Array should only contain values of types Date, Number, and String. Got ${a(t)} instead`,
                    inOperatorItems: e => `WDE0061: $in Array should have length 2, and match [String, Number]. Got ${a(e)} instead`,
                    matchesOperatorRequiredProperty: (e, t) => `WDE0062: $matches value ${a(t)} does not have property ${e}`,
                    matchesOperatorIgnoreCase: e => `WDE0063: $matches.ignoreCase should equal true. Got ${a(e)} instead`,
                    matchesOperatorSpecItems: e => `WDE0064: $matches.spec Array values should be either {"type":"anyOf","value":" -"} or {"type":"literal","value":String}. Got ${a(e)} instead`,
                    regexNotAllowed: () => "WDE0070: $regex keyword is not allowed."
                },
                D = {
                    typeIsStringOrArrayOfStrings: (e, t) => `WDE0051: Invalid ${e} parameters [${t.map(i.typeForDisplay)}]. Valid ${e} values are String, Array of String or varargs String.`
                },
                E = {
                    sortModelType: e => `WDE0065: Sort Model should be an Array. Got ${a(e)} instead`,
                    sortModelItemType: e => `WDE0066: Sort Model Array should contain values of type Object only. Got ${a(e)} instead`,
                    sortModelItem: e => `WDE0067: Sort Model Array items should have a single property with value "asc" or "desc". Got ${a(e)} instead`
                },
                P = e => `WDE0053: Internal wixData error: ${e}`,
                C = () => "WDE0080: Skip is not supported in cursor paging.",
                T = () => "WDE0109: Payload is too large.",
                x = {
                    ItemDoesNotExist: "WD_ITEM_DOES_NOT_EXIST",
                    ItemAlreadyExists: "WD_ITEM_ALREADY_EXISTS",
                    SiteInTemplateMode: "WD_SITE_IN_TEMPLATE_MODE",
                    UnknownError: "WD_UNKNOWN_ERROR",
                    ValidationError: "WD_VALIDATION_ERROR",
                    CollectionDeleted: "WD_COLLECTION_DELETED",
                    SchemaDoesNotExist: "WD_SCHEMA_DOES_NOT_EXIST",
                    PermissionDenied: "WD_PERMISSION_DENIED",
                    BadRequest: "WD_BAD_REQUEST",
                    Unauthorized: "WD_UNAUTHORIZED",
                    TooManyRequests: "WD_TOO_MANY_REQUESTS",
                    RequestTimedOut: "WD_REQUEST_TIMED_OUT",
                    QuotaExceeded: "WD_DATABASE_QUOTA_EXCEEDED",
                    QueryExecutionError: "WD_QUERY_EXECUTION_ERROR"
                };

            function W(e, t, r) {
                return R(e, t, r)
            }

            function k(e) {
                return R(e, x.ValidationError)
            }

            function R(e, t, r) {
                const i = new(t && t !== x.UnknownError ? q : Error)(e);
                return i.code = t, r && (i.details = r), i
            }

            function F(e, t, r, i, n) {
                const s = new Error(e);
                return i && (s.name = i), s.code = t, s.item = r, s.originalIndex = n, Object.setPrototypeOf(s, Object.getPrototypeOf(this)), Error.captureStackTrace && Error.captureStackTrace(s, F), s
            }

            function q(e) {
                const t = new n.UserCodeError(e);
                return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), Error.captureStackTrace && Error.captureStackTrace(t, q), t.name = Error.name, t
            }
            F.prototype = Object.create(Error.prototype, {
                constructor: {
                    value: Error,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), q.prototype = Object.create(n.UserCodeError.prototype, {
                constructor: {
                    value: q,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            });
            class V {
                constructor() {
                    this._validations = []
                }
                arityIsZero(e) {
                    return this.addValidation((() => 0 === e.length), (() => j.arityIsZero(this.operatorName)))
                }
                arityIsOne(e) {
                    return this.addValidation((() => 1 === e.length), (() => j.arityIsOne(this.operatorName)))
                }
                arityIsTwo(e) {
                    return this.addValidation((() => 2 === e.length), (() => j.arityIsTwo(this.operatorName)))
                }
                arityIsThree(e) {
                    return this.addValidation((() => 3 === e.length), (() => j.arityIsThree(this.operatorName)))
                }
                arityIsAtLeastTwo(e) {
                    return this.addValidation((() => e.length >= 2), (() => j.arityIsAtLeastTwo(this.operatorName)))
                }
                arityIsAtLeastOne(e) {
                    return this.addValidation((() => e.length >= 1), (() => j.arityIsAtLeastOne(this.operatorName)))
                }
                addValidation(e, t) {
                    return this._validations.push({
                        predicateFn: e,
                        messageFn: t
                    }), this
                }
            }
            class M extends V {
                constructor(e) {
                    super(), this._invalidArguments = (0, i.clone)(e)
                }
                validateAndAggregate() {
                    const e = this._validations.every((({
                        predicateFn: e,
                        messageFn: t
                    }) => this._appendIfInvalid(e(), t())));
                    return [this._invalidArguments, e]
                }
                _appendIfInvalid(e, t) {
                    return !!e || (this._invalidArguments.push(t), !1)
                }
            }
            class B extends V {
                validateAndReject() {
                    return Promise.resolve().then((() => {
                        this._validations.forEach((({
                            predicateFn: e,
                            messageFn: t
                        }) => {
                            if (!e()) throw k(t())
                        }))
                    }))
                }
            }
            class U extends B {
                arity(e, t, r, i) {
                    return this.addValidation((() => t.length <= i && t.length >= r), (() => v(e, r, i, t.length)))
                }
                _isObject(e, t) {
                    return this.addValidation((() => (0, i.isObject)(e)), (() => p(e, t)))
                }
                item(e, t, r) {
                    return this._isObject(e, t).addValidation((() => void 0 !== e._id ? (0, i.isString)(e._id) : !r), (() => f()))
                }
                items(e, t) {
                    return this.addValidation((() => (0, i.isArray)(e) && e.every((e => (0, i.isObject)(e) && (void 0 === e._id || null === e._id || (0, i.isString)(e._id))))), (() => m(t))).addValidation((() => e.length <= 1e3), (() => g(t)))
                }
                fieldName(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => h()))
                }
                itemId(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => c()))
                }
                itemIds(e, t) {
                    return this.addValidation((() => (0, i.isArray)(e) && e.every((e => (0, i.isString)(e)))), (() => u())).addValidation((() => e.length <= 1e3), (() => d(t)))
                }
                _options(e, t) {
                    return this.addValidation((() => {
                        const r = (0, i.isObject)(e) && t.every((t => {
                            return "language" === t ? null == (r = e[t]) || (0, i.isString)(r) && r.length > 0 : function(e) {
                                return null == e || (0, i.isBoolean)(e)
                            }(e[t]);
                            var r
                        }));
                        return null == e || r
                    }), (() => b(t)))
                }
                referenceRemoveParameters(e) {
                    return this.addValidation((() => (0, i.isArray)(e) && e.every(Q)), A)
                }
                referenceParameters(e) {
                    return this.addValidation((() => (0, i.isArray)(e) && e.every(G)), A)
                }
                referenceParameter(e) {
                    return this.addValidation((() => G(e)), A)
                }
                isNonEmptyString(e, t) {
                    return this.addValidation((() => "string" == typeof e && e.length > 0), (() => $.isNonEmptyString(t)))
                }
                references(e) {
                    return this.addValidation((() => (0, i.isArray)(e) && e.every((e => (0, i.isString)(e.relationshipName) && G(e.left) && G(e.right)))), S)
                }
                options(e) {
                    return this._options(e, ["suppressAuth", "suppressHooks", "showDrafts", "consistentRead", "language"])
                }
                bulkInsertOptions(e) {
                    return this._options(e, ["suppressAuth", "suppressHooks", "overrideExisting"])
                }
                bulkUpdateOptions(e) {
                    return this._options(e, ["suppressAuth", "suppressHooks", "showDrafts"])
                }
                bulkRemoveOptions(e) {
                    return this._options(e, ["suppressAuth", "suppressHooks", "showDrafts"])
                }
                truncateOptions(e) {
                    return this._options(e, ["suppressAuth"])
                }
                collectionName(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => l()))
                }
            }

            function z() {
                return new U
            }

            function G(e) {
                return (0, i.isString)(e) && "" !== e || (0, i.isObject)(e) && e.hasOwnProperty("_id")
            }

            function Q(e) {
                return (0, i.isString)(e) || (0, i.isObject)(e) && e.hasOwnProperty("_id")
            }
            var L = r(69012),
                H = r.n(L);

            function J(e) {
                return "array" === H()(e)
            }

            function X(e) {
                return "date" === H()(e)
            }

            function Z(e) {
                return "string" === H()(e)
            }

            function Y(e) {
                return function(e) {
                    if (!Z(e)) return e;
                    const t = e.slice(0, 1).toUpperCase(),
                        r = e.slice(1, e.length);
                    return t + r
                }(H()(e))
            }

            function K(e) {
                if (null == e || "object" != typeof e) return e;
                let t = null;
                if (X(e)) t = new Date(e.getTime());
                else {
                    t = e.constructor();
                    for (const r in e) t[r] = K(e[r])
                }
                return t
            }
            class ee {
                constructor(e, t, r) {
                    this._validations = [], this.operatorName = e, this.ctor = r, this._invalidArguments = K(t)
                }
                typeIsString(e) {
                    return this.addValidation((() => Z(e)), (() => `Invalid ${this.operatorName} parameter value [${Y(e)}]. ${this.operatorName} parameter must be a String.`))
                }
                typeIsStringNumberOrDate(e) {
                    return this.addValidation((() => te(e)), (() => `Invalid ${this.operatorName} parameter value [${Y(e)}]. Valid ${this.operatorName} parameter types are String, Number or Date.`))
                }
                sameType(e, t) {
                    return this.addValidation((() => Y(e) === Y(t)), (() => `Invalid ${this.operatorName} parameter values [${Y(e)}] and [${Y(t)}]. Both parameters must be of the same type.`))
                }
                typeIsStringNumberOrDateForAll(e) {
                    return this.addValidation((() => e.every(te)), (() => `Invalid ${this.operatorName} usage. ${this.operatorName} supports only Number, String or Date items.`))
                }
                validFieldName(e) {
                    return this.addValidation((() => Z(e)), (() => `Invalid ${this.operatorName} field value [${Y(e)}]. ${this.operatorName} field must be a String.`))
                }
                isInstanceOfSameClass(e) {
                    return this.addValidation((() => e instanceof this.ctor), (() => `Invalid ${this.operatorName} parameter [${Y(e)}]. ${this.operatorName} expects FilterBuilder only.`))
                }
                arityIsOne(e) {
                    return this.addValidation((() => 1 === e.length), (() => `Invalid ${this.operatorName} usage. ${this.operatorName} requires one parameter.`))
                }
                arityIsTwo(e) {
                    return this.addValidation((() => 2 === e.length), (() => `Invalid ${this.operatorName} usage. ${this.operatorName} requires two parameters.`))
                }
                arityIsThree(e) {
                    return this.addValidation((() => 3 === e.length), (() => `Invalid ${this.operatorName} usage. ${this.operatorName} requires three parameters.`))
                }
                arityIsAtLeastTwo(e) {
                    return this.addValidation((() => e.length >= 2), (() => `Invalid ${this.operatorName} usage. ${this.operatorName} requires at least two parameters.`))
                }
                addValidation(e, t) {
                    return this._validations.push({
                        predicateFn: e,
                        messageFn: t
                    }), this
                }
                validateAndAggregate() {
                    const e = this._validations.every((({
                        predicateFn: e,
                        messageFn: t
                    }) => this._appendIfInvalid(e(), t())));
                    return [this._invalidArguments, e]
                }
                _appendIfInvalid(e, t) {
                    return !!e || (this._invalidArguments.push(t), !1)
                }
            }

            function te(e) {
                return Z(e) || (t = e, "number" === H()(t)) || X(e);
                var t
            }
            const re = [function(e) {
                const t = e.$and;
                if (Array.isArray(t) && 1 === t.length) return t[0]
            }, function(e) {
                const t = e.$and;
                if (Array.isArray(t) && 0 === t.length) return {};
                return null
            }, function(e) {
                const t = e.$and;
                if (!t) return;
                let r = [],
                    i = [];
                if (t.forEach((e => {
                        ! function(e) {
                            const t = Object.keys(e);
                            return t.every((e => e.startsWith("$"))) && t.length > 0
                        }(e) ? r = [...r, e]: i = [...i, e]
                    })), r.length <= 1 || function(e) {
                        const t = e.map((e => Object.keys(e))).reduce(((e, t) => [...e, ...t]), []);
                        return function(e) {
                            const t = {};
                            return e.forEach((e => t[e] = !0)), Object.keys(t)
                        }(t).length !== t.length
                    }(r)) return;
                return {
                    $and: [Object.assign({}, ...r), ...i]
                }
            }, function(e) {
                const t = e.$and;
                if (!t) return;
                if (!t.find((e => e.$and))) return;
                return {
                    $and: t.reduce(((e, t) => {
                        const r = t.$and;
                        return r ? [...e, ...r] : [...e, t]
                    }), [])
                }
            }, function(e) {
                const t = e.$or;
                if (!t) return;
                if (!t.find((e => e.$or))) return;
                return {
                    $or: t.reduce(((e, t) => {
                        const r = t.$or;
                        return r ? [...e, ...r] : [...e, t]
                    }), [])
                }
            }];

            function ie(e) {
                const [t] = ne(e);
                return t
            }

            function ne(e) {
                return Array.isArray(e) ? function(e) {
                    const t = e.map(ne),
                        r = 0 < t.filter((([, e]) => e)).length;
                    return [t.map((([e]) => e)), r]
                }(e) : "object" != typeof e || null === e || e instanceof Date ? [e, !1] : function(e) {
                    const [t, r] = o(e), [i, n] = s(t);
                    return [i, r || n];

                    function s(e) {
                        const t = function(e) {
                            for (const t of re) {
                                const r = t(e);
                                if (r) return r
                            }
                        }(e);
                        if (!t) return [e, !1];
                        const [r] = ne(t);
                        return [r, !0]
                    }

                    function o(e) {
                        const t = Object.entries(e).map(a).filter((([, , e]) => e));
                        return [{ ...e,
                            ...l(t)
                        }, !!t.length]
                    }

                    function a([e, t]) {
                        const [r, i] = ne(t);
                        return [e, r, i]
                    }

                    function l(e) {
                        return e.reduce(((e, [t, r]) => ({ ...e,
                            [t]: r
                        })), {})
                    }
                }(e)
            }

            function se(...e) {
                return {
                    $and: e
                }
            }

            function oe(e) {
                return e && e.$and && 0 === e.$and.length
            }
            var ae = (e = class {}) => class extends e {
                constructor(e = {}) {
                    super(e), this.filterTree = e.filterTree || {
                        $and: []
                    }, this.invalidArguments = e.invalidArguments || [], this.encoder = e.encoder || {}
                }
                eq(...e) {
                    return this._binaryAnd("$eq", ".eq", e)
                }
                ne(...e) {
                    return this._binaryAnd("$ne", ".ne", e)
                }
                ge(...e) {
                    return this._AndLogicalEquivalence("$gte", ".ge", e)
                }
                gt(...e) {
                    return this._AndLogicalEquivalence("$gt", ".gt", e)
                }
                le(...e) {
                    return this._AndLogicalEquivalence("$lte", ".le", e)
                }
                lt(...e) {
                    return this._AndLogicalEquivalence("$lt", ".lt", e)
                }
                isNotEmpty(e) {
                    const [t, r] = this._filterValidator(".isNotEmpty").arityIsOne(arguments).validFieldName(e).validateAndAggregate();
                    return r ? this.ne(e, null) : this._copy(this.filterTree, t)
                }
                isEmpty(e) {
                    const [t, r] = this._filterValidator(".isEmpty").arityIsOne(arguments).validFieldName(e).validateAndAggregate();
                    return r ? this.eq(e, null) : this._copy(this.filterTree, t)
                }
                startsWith(...e) {
                    return this._AndStringOperand("$startsWith", ".startsWith", e)
                }
                endsWith(...e) {
                    return this._AndStringOperand("$endsWith", ".endsWith", e)
                }
                contains(...e) {
                    return this._AndStringOperand("$contains", ".contains", e)
                }
                hasSome(...e) {
                    return this._AndSetOperand("$hasSome", ".hasSome", e)
                }
                hasAll(...e) {
                    return this._AndSetOperand("$hasAll", ".hasAll", e)
                }
                or(e) {
                    const [t, r] = this._filterValidator(".or").arityIsOne(arguments).isInstanceOfSameClass(e).validateAndAggregate();
                    if (r) {
                        const r = oe(this.filterTree) ? [] : [this.filterTree];
                        return this._copy(se({
                            $or: [...r, e.filterTree]
                        }), t.concat(e.invalidArguments))
                    }
                    return this._copy(this.filterTree, t)
                }
                and(e) {
                    const [t, r] = this._filterValidator(".and").arityIsOne(arguments).isInstanceOfSameClass(e).validateAndAggregate();
                    if (r) {
                        const r = oe(this.filterTree) ? [] : [this.filterTree];
                        return this._copy(se(...r, e.filterTree), t.concat(e.invalidArguments))
                    }
                    return this._copy(this.filterTree, t)
                }
                not(e) {
                    const [t, r] = this._filterValidator(".not").arityIsOne(arguments).isInstanceOfSameClass(e).validateAndAggregate();
                    if (r) {
                        const r = function(...e) {
                            return {
                                $and: e.reduce(((e, t) => J(t.$and) ? e.concat(t.$and) : e.concat([t])), [])
                            }
                        }(K(this.filterTree), {
                            $not: [e.filterTree]
                        });
                        return this._copy(r, t.concat(e.invalidArguments))
                    }
                    return this._copy(this.filterTree, t)
                }
                between(e, t, r) {
                    const [i, n] = this._filterValidator(".between").arityIsThree(arguments).sameType(t, r).typeIsStringNumberOrDate(t).typeIsStringNumberOrDate(r).validateAndAggregate();
                    return n ? this.ge(e, t).lt(e, r) : this._copy(this.filterTree, i)
                }
                getFilterModel() {
                    if (this.invalidArguments.length > 0) throw new Error(this.invalidArguments.join(" "));
                    return ie(this.filterTree)
                }
                setFilterModel(e) {
                    return this._copy(e, [])
                }
                _binaryAnd(e, t, r) {
                    const [i, n] = Array.prototype.slice.call(r), [s] = this._filterValidator(t).arityIsTwo(r).validFieldName(i).validateAndAggregate(), o = this._makeNewFilter(i, e, n);
                    return this._copy(o, s)
                }
                _AndLogicalEquivalence(e, t, r) {
                    const [i, n] = Array.prototype.slice.call(r), [s] = this._filterValidator(t).arityIsTwo(r).validFieldName(i).typeIsStringNumberOrDate(n).validateAndAggregate(), o = this._makeNewFilter(i, e, n);
                    return this._copy(o, s)
                }
                _AndStringOperand(e, t, r) {
                    const [i, n] = Array.prototype.slice.call(r), [s] = this._filterValidator(t).arityIsTwo(r).validFieldName(i).typeIsString(n).validateAndAggregate(), o = this._makeNewFilter(i, e, n);
                    return this._copy(o, s)
                }
                _AndSetOperand(e, t, r) {
                    const [i, ...n] = Array.prototype.slice.call(r), s = J(n[0]) ? n[0] : n, [o] = this._filterValidator(t).arityIsAtLeastTwo(r).validFieldName(i).typeIsStringNumberOrDateForAll(s).validateAndAggregate(), a = this._makeNewFilter(i, e, s);
                    return this._copy(a, o)
                }
                _makeNewFilter(e, t, r) {
                    const i = K(this.filterTree),
                        n = void 0 === r ? null : r,
                        s = this._buildFilter(e, t, n);
                    if (J(i.$and)) return i.$and.push(s), i;
                    return o = i, 0 === Object.keys(o).length ? se(s) : se(i, s);
                    var o
                }
                _buildFilter(e, t, r) {
                    if ("$eq" !== t) {
                        const i = {};
                        return i[e] = {}, i[e][t] = this._encode(r), i
                    } {
                        const t = {};
                        return t[e] = this._encode(r), t
                    }
                }
                _encode(e) {
                    return t = this.encoder, "function" === H()(t) ? this.encoder(e) : e;
                    var t
                }
                _copy(e, t) {
                    return new this.constructor({ ...this,
                        filterTree: e,
                        invalidArguments: t
                    })
                }
                _filterValidator(e) {
                    return new ee(e, this.invalidArguments, this.constructor)
                }
            };
            ae();

            function le(e) {
                const t = e.split("-"),
                    r = [];
                for (let e = 0; e < t.length - 1; e++) i(r, t[e]), r.push({
                    type: "anyOf",
                    value: " \t\n-"
                });
                return i(r, t[t.length - 1]), r;

                function i(e, t) {
                    0 !== t.length && e.push({
                        type: "literal",
                        value: t
                    })
                }
            }
            class ce extends M {
                constructor(e, t, r, i) {
                    super(t), this.operatorName = e, this.ctor = r, this.constructorName = i
                }
                typeIsString(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => O.typeIsString(this.operatorName, e)))
                }
                typeIsStringNumberOrDate(e) {
                    return this.addValidation((() => ue(e)), (() => O.typeIsStringNumberOrDate(this.operatorName, e)))
                }
                sameType(e, t) {
                    return this.addValidation((() => (0, i.typeForDisplay)(e) === (0, i.typeForDisplay)(t)), (() => O.sameType(this.operatorName, e, t)))
                }
                typeIsStringNumberOrDateForAll(e) {
                    return this.addValidation((() => e.every(ue)), (() => O.typeIsStringNumberOrDateForAll(this.operatorName)))
                }
                validFieldName(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => O.validFieldName(this.operatorName, e)))
                }
                isInstanceOfSameClass(e) {
                    return this.addValidation((() => e instanceof this.ctor), (() => O.isInstanceOfSameClass(this.operatorName, this.constructorName, e)))
                }
                isForCollection(e, t) {
                    return this.addValidation((() => e.collectionName === t), (() => O.isForCollection(this.operatorName, this.constructorName, e.collectionName)))
                }
            }

            function ue(e) {
                return (0, i.isString)(e) || (0, i.isNumber)(e) || (0, i.isDate)(e)
            }
            var de = (e = class {}) => class extends(ae(e)) {
                or(e) {
                    const t = super.or.apply(this, arguments);
                    return this._validateCollectionName(t, e, ".or")
                }
                and(e) {
                    const t = super.and.apply(this, arguments);
                    return this._validateCollectionName(t, e, ".and")
                }
                not(e) {
                    const t = super.not.apply(this, arguments);
                    return this._validateCollectionName(t, e, ".not")
                }
                _validateCollectionName(e, t, r) {
                    if (e.invalidArguments.length > 0) return e;
                    const i = function(e, t) {
                            if (!e || !e.constructor) return e;
                            const r = e.collectionName ? e.collectionName : t;
                            return new e.constructor({ ...e,
                                collectionName: r
                            })
                        }(t, this.collectionName),
                        [n, s] = new ce(r, e.invalidArguments, this.constructor, this.constructorName).isForCollection(i, this.collectionName).validateAndAggregate();
                    return s ? e : this._copy(this.filterTree, n)
                }
                _matchesUrlized(e, t) {
                    const [r, i] = this._filterValidator("._matchesUrlized").arityIsTwo(arguments).validFieldName(e).typeIsString(t).validateAndAggregate();
                    if (i) {
                        const i = this._makeNewFilter(e, ... function(e) {
                            return t(e) ? ["$in", [e, Number.parseInt(e)]] : ["$matches", {
                                ignoreCase: !0,
                                spec: le(e)
                            }];

                            function t(e) {
                                return /^-?[0-9]{1,16}$/.test(e)
                            }
                        }(t));
                        return this._copy(i, r)
                    }
                    return this._copy(this.filterTree, r)
                }
                getFilterModel() {
                    if (this.invalidArguments.length > 0) throw k(_(this.invalidArguments));
                    return super.getFilterModel()
                }
                _filterValidator(e) {
                    return new ce(e, this.invalidArguments, this.constructor, this.constructorName)
                }
            };
            class he extends(de()) {
                get constructorName() {
                    return "FilterBuilder"
                }
                _build() {
                    return this.getFilterModel()
                }
            }
            de();

            function pe() {
                return new he({})
            }
            class me extends M {
                constructor(e, t) {
                    super(t), this.operatorName = e
                }
                allStrings(e) {
                    return this.addValidation((() => e.every(i.isString)), (() => D.typeIsStringOrArrayOfStrings(this.operatorName, e)))
                }
            }
            var ge = (e = class {}) => class extends e {
                constructor(e = {}) {
                    super(e), this.orderBy = e.orderBy || [], this.invalidArguments = e.invalidArguments || []
                }
                ascending(...e) {
                    return this._sortClause("asc", ".ascending", e)
                }
                descending(...e) {
                    return this._sortClause("desc", ".descending", e)
                }
                getSortModel() {
                    if (this.invalidArguments.length > 0) throw k(I(this.invalidArguments));
                    return this.orderBy
                }
                setSortModel(e) {
                    return this._copySort(e, [])
                }
                _sortClause(e, t, r) {
                    let n = [];
                    this.orderBy && (n = (0, i.clone)(this.orderBy));
                    const s = (o = n, a = e, e => {
                        const t = {};
                        t[e] = a, o.push(t)
                    });
                    var o, a;
                    const l = (0, i.isArray)(r[0]) && 1 === r.length ? r[0] : Array.prototype.slice.call(r, 0),
                        [c, u] = this._sortValidator(t).arityIsAtLeastOne(r).allStrings(l).validateAndAggregate();
                    return u && l.forEach(s), this._copySort(n, c)
                }
                _sortValidator(e) {
                    return new me(e, this.invalidArguments)
                }
                _copySort(e, t) {
                    return new this.constructor({ ...this,
                        orderBy: e,
                        invalidArguments: t
                    })
                }
            };

            function fe(e) {
                return "string" == typeof e && e.length > 0
            }
            class ve {
                constructor(e) {
                    e && (this.count = e.count, this.total = e.total, this.cursors = e.cursors, this.hasNext = e.hasNext, this.hasPrev = e.hasPrev)
                }
            }

            function ye(e, t, r) {
                const i = e.skipNumber || 0;
                let n = void 0 === e.limitNumber ? t : e.limitNumber;
                return r && (n = Math.min(n, t)), r ? i + n : i - n
            }
            const _e = 9007199254740991;
            class Ne extends(de(ge())) {
                constructor(e) {
                    super(e), this.provider = e.provider, this.collectionName = e.collectionName, this.limitNumber = e.limitNumber, this.invalidArguments = e.invalidArguments, this.orderBy = e.orderBy, this.skipNumber = e.skipNumber, this.included = e.included, this.projectedFields = e.projectedFields, this.cursor = e.cursor
                }
                get constructorName() {
                    return "WixDataQuery"
                }
                count(e) {
                    return Ie(this.invalidArguments, this.collectionName).then((() => z().options(e).validateAndReject())).then((() => this.provider.count(this.collectionName, this.getOptimizedFilter(), e))).then((e => e.totalCount))
                }
                distinct(e, t) {
                    const r = this,
                        i = (t || {}).omitTotalCount,
                        n = this.cursor ? void 0 : this.skipNumber,
                        s = this.cursor ? "" : e;
                    return Ie(this.invalidArguments, this.collectionName).then((() => z().options(t).validateAndReject())).then((() => z().fieldName(s).validateAndReject())).then((() => this.provider.distinct(this.collectionName, this.getOptimizedFilter(), this.orderBy, s, n, this.limitNumber, t, this.cursor, void 0, i))).then((e => {
                        const i = e.pagingMetadata || new ve,
                            {
                                cursors: n,
                                hasNext: o = !1
                            } = i,
                            a = fe(n ? .next) || fe(n ? .prev) ? { ...t,
                                omitTotalCount: !0
                            } : t;
                        return new Ae({
                            createdByCursor: this.cursor,
                            items: e.items,
                            length: e.items.length,
                            query: r,
                            totalCount: e.totalCount,
                            cursors: n,
                            partialIncludes: !1,
                            pagingFunction() {
                                return this.distinct(s, a)
                            },
                            hasNext: o
                        })
                    }))
                }
                _transformOrderingForAggregates(e = [], t) {
                    return e.length > 0 ? e.filter((e => e.hasOwnProperty(t))).map((e => ({
                        _id: e[t]
                    }))) : null
                }
                _distinctValuesPipeline(e) {
                    return [this.filterTree && Object.keys(this.filterTree).length > 0 ? {
                        $match: this.filterTree
                    } : null, {
                        $distinct: `$${e}`
                    }].filter(this._stageFilter)
                }
                _stageFilter(e) {
                    return null !== e
                }
                fields(...e) {
                    const t = (0, i.clone)(this.projectedFields);
                    for (let r = 0; r < e.length; r++) t.push(e[r]);
                    return new Ne({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        orderBy: this.orderBy,
                        skipNumber: this.skipNumber,
                        limitNumber: this.limitNumber,
                        invalidArguments: this.invalidArguments,
                        included: this.included,
                        cursor: this.cursor,
                        projectedFields: t
                    })
                }
                find(e) {
                    const t = this,
                        r = (e || {}).omitTotalCount;
                    return Ie(this.invalidArguments, this.collectionName).then((() => z().options(e).validateAndReject())).then((() => {
                        const t = this.cursor ? void 0 : this.skipNumber;
                        return this.provider.find(this.collectionName, this.getOptimizedFilter(), this.orderBy, t, this.limitNumber, e, this.included, r, this.cursor, this.projectedFields)
                    })).then((r => {
                        const i = r.pagingMetadata.cursors,
                            n = fe(i ? .next) || fe(i ? .prev) ? { ...e,
                                omitTotalCount: !0
                            } : e;
                        return new Ae({
                            createdByCursor: this.cursor,
                            totalCount: r.totalCount,
                            query: t,
                            items: r.items,
                            cursors: i,
                            partialIncludes: r.partialIncludes,
                            hasNext: r.pagingMetadata.hasNext,
                            pagingFunction() {
                                return this.find(n)
                            }
                        })
                    }))
                }
                limit(e) {
                    const [t] = this._queryValidator(".limit").arityIsOne(arguments).isPositiveNumber(e).isInteger(e).validateAndAggregate();
                    return new Ne({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        orderBy: this.orderBy,
                        skipNumber: this.skipNumber,
                        limitNumber: e,
                        included: this.included,
                        cursor: this.cursor,
                        invalidArguments: t,
                        projectedFields: this.projectedFields
                    })
                }
                skip(e) {
                    const [t] = this._queryValidator(".skip").arityIsOne(arguments).isNonNegativeNumber(e).isInteger(e).validateAndAggregate();
                    return new Ne({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        orderBy: this.orderBy,
                        skipNumber: e,
                        limitNumber: this.limitNumber,
                        included: this.included,
                        cursor: this.cursor,
                        invalidArguments: t,
                        projectedFields: this.projectedFields
                    })
                }
                include(...e) {
                    const t = (0, i.clone)(this.included);
                    for (let r = 0; r < e.length; r++) t.push(e[r]);
                    return new Ne({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        orderBy: this.orderBy,
                        skipNumber: this.skipNumber,
                        limitNumber: this.limitNumber,
                        invalidArguments: this.invalidArguments,
                        included: t,
                        cursor: this.cursor,
                        projectedFields: this.projectedFields
                    })
                }
                setFilterModel(e) {
                    const t = super.setFilterModel(e);
                    return this._setQuerySpecificInvalidArguments(t)
                }
                getOptimizedFilter() {
                    try {
                        return ie(this.filterTree)
                    } catch (e) {
                        return this.filterTree
                    }
                }
                setSortModel(e) {
                    const t = super.setSortModel(e);
                    return this._setQuerySpecificInvalidArguments(t)
                }
                _setQuerySpecificInvalidArguments(e) {
                    const t = (e, t) => void 0 !== e ? t.validateAndAggregate()[0] : [],
                        r = this._queryValidator(".limit", []).isPositiveNumber(this.limitNumber).isInteger(this.limitNumber),
                        i = this._queryValidator(".skip", []).isNonNegativeNumber(this.skipNumber).isInteger(this.skipNumber),
                        n = [...t(this.limitNumber, r), ...t(this.skipNumber, i)];
                    return Object.assign(e, {
                        invalidArguments: n
                    })
                }
                _queryValidator(e, t = this.invalidArguments) {
                    return new Se(e, t)
                }
            }

            function Ie(e, t) {
                const r = ((0, i.isString)(t) ? [] : [l()]).concat(e);
                return r.length > 0 ? Promise.reject(k($.queryInvalid(t, r))) : Promise.resolve()
            }

            function be(e, t) {
                return new Ne({
                    provider: e,
                    collectionName: t,
                    filterTree: {},
                    orderBy: void 0,
                    skipNumber: 0,
                    invalidArguments: [],
                    included: [],
                    projectedFields: []
                })
            }
            class Ae {
                constructor(e) {
                    this._executeQuery = e => this._pagingFunction.bind(e)(), this._withCalculatedSkip = (e, t) => (e.skipNumber = ye(this.query, this.length, t), Promise.resolve(e)), e && (this._items = e.items, this._totalCount = e.totalCount, this._cursors = e.cursors, this._createdByCursor = e.createdByCursor, this._query = e.query, this._partialIncludes = e.partialIncludes, this._pagingFunction = e.pagingFunction, this._hasNext = e.hasNext, this.nextSkipNumber = ye(this.query, this.length, !0), this.prevSkipNumber = ye(this.query, this.length, !1))
                }
                get items() {
                    return this._items
                }
                get length() {
                    return this.items.length
                }
                get totalCount() {
                    return this._totalCount
                }
                get query() {
                    return this._query
                }
                get pageSize() {
                    return this._query.limitNumber
                }
                get totalPages() {
                    if (this.totalCount && this.pageSize) return Math.ceil(this.totalCount / this.pageSize);
                    if (0 === this.totalCount) return 0;
                    const e = this.query.skipNumber || 0;
                    return this.totalCount && this.length + e <= this.totalCount ? Math.ceil(this.totalCount / this.length) : void 0
                }
                get currentPage() {
                    if (0 === this.length) return;
                    const e = this.query.skipNumber || 0;
                    return this.totalCount <= 0 || e >= this.totalCount || void 0 === this.pageSize ? this.hasNext() ? Math.floor(e / this.length) : void 0 : Math.floor(e / this.pageSize)
                }
                get partialIncludes() {
                    return this._partialIncludes
                }
                next() {
                    return this.hasNext() ? fe(this.nextCursor) ? this._getNewCursorQuery(this.nextCursor, !0).then((e => this._executeQuery(e))).then((e => e._withTotalCount(this._totalCount))) : this._getNewQuery(!0).then((e => this._executeQuery(e))) : this._rejectNoNextPage()
                }
                prev() {
                    return this.hasPrev() ? fe(this.prevCursor) ? this._getNewCursorQuery(this.prevCursor, !1).then((e => this._executeQuery(e))).then((e => e._withTotalCount(this._totalCount))) : this._getNewQuery(!1).then((e => this._executeQuery(e))) : this._rejectNoPrevPage()
                }
                get nextCursor() {
                    return this._cursors && this._cursors.next
                }
                get prevCursor() {
                    return this._cursors && this._cursors.prev
                }
                hasNext() {
                    return this._hasNext
                }
                hasPrev() {
                    if (fe(this._createdByCursor) || this._cursors) return fe(this.prevCursor);
                    if (0 === (this.query.skipNumber || 0) || this.totalCount <= 0) return !1;
                    return ye(this.query, this.length, !1) >= 0
                }
                toJSON() {
                    return {
                        currentPage: this.currentPage,
                        items: this.items,
                        length: this.length,
                        pageSize: this.pageSize,
                        partialIncludes: this.partialIncludes,
                        query: this.query,
                        totalCount: this.totalCount,
                        totalPages: this.totalPages
                    }
                }
                _getNewQuery(e) {
                    return this._withCalculatedSkip(new Ne({
                        provider: this.query.provider,
                        collectionName: this.query.collectionName,
                        filterTree: this.query.filterTree,
                        orderBy: this.query.orderBy,
                        limitNumber: this.query.limitNumber,
                        included: this.query.included,
                        invalidArguments: [],
                        projectedFields: this.query.projectedFields
                    }), e)
                }
                _getNewCursorQuery(e, t) {
                    const r = new Ne({
                        provider: this.query.provider,
                        collectionName: this.query.collectionName,
                        filterTree: {},
                        limitNumber: this.query.limitNumber,
                        invalidArguments: [],
                        cursor: e,
                        included: this.query.included,
                        projectedFields: this.query.projectedFields
                    });
                    return this._withCalculatedSkip(r, t)
                }
                _withTotalCount(e) {
                    return this._totalCount = e, this
                }
                _rejectNoPrevPage() {
                    return Promise.reject(k($.noPrevPage(this.query.collectionName)))
                }
                _rejectNoNextPage() {
                    return Promise.reject(k($.noNextPage(this.query.collectionName)))
                }
            }
            class Se extends M {
                constructor(e, t) {
                    super(t), this.operatorName = e
                }
                _isNumber(e, t) {
                    return this.addValidation((() => (0, i.isNumber)(t)), (() => $.isNumber(this.operatorName, e, t)))
                }
                isPositiveNumber(e) {
                    return this._isNumber("positive", e).addValidation((() => !Number.isNaN(e) && e > 0), (() => $.isPositiveNumber(this.operatorName, e)))
                }
                isNonNegativeNumber(e) {
                    return this._isNumber("non-negative", e).addValidation((() => !Number.isNaN(e) && e >= 0), (() => $.isNonNegativeNumber(this.operatorName, e)))
                }
                isInteger(e) {
                    return this.addValidation((() => !Number.isNaN(e) && Number.isFinite(e) && Number.isInteger(e) && e < _e && e > -9007199254740991), (() => $.isInteger(this.operatorName, e)))
                }
                notGreaterThan(e, t) {
                    return this.addValidation((() => e <= t), (() => $.notGreaterThan(this.operatorName, e, t)))
                }
            }
            const $e = (e = class {}) => class extends e {
                constructor(e = {}) {
                    super(e), this.groupByTree = e.groupByTree, this.invalidArguments = e.invalidArguments || []
                }
                sum(e, t) {
                    const [r] = this._groupValidator(".sum").arityIsAtLeastOne(arguments).typeIsString(e).validateAndAggregate();
                    return this._addAccumulator("sum", e, t, r)
                }
                avg(e, t) {
                    const [r] = this._groupValidator(".avg").arityIsAtLeastOne(arguments).typeIsString(e).validateAndAggregate();
                    return this._addAccumulator("avg", e, t, r)
                }
                min(e, t) {
                    const [r] = this._groupValidator(".min").arityIsAtLeastOne(arguments).typeIsString(e).validateAndAggregate();
                    return this._addAccumulator("min", e, t, r)
                }
                max(e, t) {
                    const [r] = this._groupValidator(".max").arityIsAtLeastOne(arguments).typeIsString(e).validateAndAggregate();
                    return this._addAccumulator("max", e, t, r)
                }
                count() {
                    const [e] = this._groupValidator(".count").arityIsZero(arguments).validateAndAggregate(), t = (0, i.clone)(this.groupByTree) || {
                        _id: De()
                    };
                    return t.count = {
                        $sum: 1
                    }, this._copy(t, e)
                }
                _addAccumulator(e, t, r, n) {
                    const s = (0, i.clone)(this.groupByTree) || {
                            _id: De()
                        },
                        o = r || t + ((a = e).charAt(0).toUpperCase() + a.slice(1));
                    var a;
                    const l = {};
                    return l[`$${e}`] = `$${t}`, s[o] = l, this._copy(s, n)
                }
                _copy(e, t) {
                    return new this.constructor({ ...this,
                        groupByTree: e,
                        invalidArguments: t
                    })
                }
                _groupValidator(e) {
                    return new Oe(e, this.invalidArguments)
                }
            };
            class je extends($e()) {
                _build() {
                    return function(e) {
                        if (e.length > 0) throw k(N(e))
                    }(this.invalidArguments), this.groupByTree
                }
            }
            class Oe extends M {
                constructor(e, t) {
                    super(t), this.operatorName = e
                }
                typeIsString(e) {
                    return this.addValidation((() => (0, i.isString)(e)), (() => O.typeIsString(this.operatorName, e)))
                }
            }

            function we(...e) {
                const t = De(...e);
                return new je({
                    groupByTree: {
                        _id: t
                    }
                })
            }

            function De(...e) {
                if (1 === e.length) return `$${e}`;
                if (e.length > 1) {
                    const t = {};
                    return e.forEach((e => t[e] = `$${e}`)), t
                }
                return "0"
            }
            class Ee extends(ge($e())) {
                constructor(e = {}) {
                    super(e), this.provider = e.provider, this.collectionName = e.collectionName, this.filterTree = e.filterTree, this.havingTree = e.havingTree, this.skipNumber = e.skipNumber || 0, this.limitNumber = e.limitNumber, this.cursor = e.cursor, this.invalidArguments = e.invalidArguments || []
                }
                filter(e) {
                    const [t] = this._aggregateValidator(".filter").arityIsOne(arguments).filterIsNotSet(this).filterBuilder(e).validateAndAggregate();
                    return new Ee({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: e.filterTree,
                        groupByTree: this.groupByTree,
                        havingTree: this.havingTree,
                        skipNumber: this.skipNumber,
                        limitNumber: this.limitNumber,
                        cursor: this.cursor,
                        orderBy: this.orderBy,
                        invalidArguments: t.concat(e.invalidArguments)
                    })
                }
                group(...e) {
                    let t = (0, i.clone)(this.groupByTree);
                    const [r] = this._aggregateValidator(".group").arityIsAtLeastOne(arguments).groupIsNotSet(t).validateAndAggregate();
                    return t ? "0" === t._id && (t = { ...t,
                        _id: De(...e)
                    }) : t = {
                        _id: De(...e)
                    }, new Ee({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        groupByTree: t,
                        havingTree: this.havingTree,
                        skipNumber: this.skipNumber,
                        limitNumber: this.limitNumber,
                        cursor: this.cursor,
                        orderBy: this.orderBy,
                        invalidArguments: r
                    })
                }
                having(e) {
                    const [t] = this._aggregateValidator(".having").arityIsOne(arguments).havingIsNotSet(this).filterBuilder(e).validateAndAggregate();
                    return new Ee({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        groupByTree: this.groupByTree,
                        havingTree: e.filterTree,
                        skipNumber: this.skipNumber,
                        limitNumber: this.limitNumber,
                        cursor: this.cursor,
                        orderBy: this.orderBy,
                        invalidArguments: t.concat(e.invalidArguments)
                    })
                }
                skip(e) {
                    const [t] = this._aggregateValidator(".skip").arityIsOne(arguments).isNonNegativeNumber(e).isInteger(e).validateAndAggregate();
                    return new Ee({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        groupByTree: this.groupByTree,
                        havingTree: this.havingTree,
                        skipNumber: e,
                        limitNumber: this.limitNumber,
                        cursor: this.cursor,
                        orderBy: this.orderBy,
                        invalidArguments: t
                    })
                }
                limit(e) {
                    const [t] = this._aggregateValidator(".limit").arityIsOne(arguments).isPositiveNumber(e).isInteger(e).validateAndAggregate();
                    return new Ee({
                        provider: this.provider,
                        collectionName: this.collectionName,
                        filterTree: this.filterTree,
                        groupByTree: this.groupByTree,
                        havingTree: this.havingTree,
                        skipNumber: this.skipNumber,
                        limitNumber: e,
                        cursor: this.cursor,
                        orderBy: this.orderBy,
                        invalidArguments: t
                    })
                }
                run(e) {
                    const t = this,
                        r = this._buildPipeline();
                    return (i = this.invalidArguments, n = this.collectionName, i.length > 0 ? Promise.reject(k(y.aggregateInvalid(n, i))) : Promise.resolve()).then((() => z().options(e).validateAndReject())).then((() => this.provider.runAggregate(this.collectionName, r, this.limitNumber, e, this.cursor))).then((({
                        items: e,
                        hasNext: r,
                        cursors: i
                    }) => new Te({
                        items: e,
                        hasNext: r,
                        aggregate: t,
                        pageSize: e.length,
                        cursors: i,
                        createdByCursor: this.cursor
                    })));
                    var i, n
                }
                _buildPipeline() {
                    return [this.filterTree ? {
                        $match: this.filterTree
                    } : null, this.groupByTree ? {
                        $group: this.groupByTree
                    } : null, this.groupByTree ? {
                        $project: Pe(this.groupByTree)
                    } : null, this.havingTree ? {
                        $match: this.havingTree
                    } : null, this.orderBy.length > 0 ? {
                        $sort: this.orderBy
                    } : null, {
                        $skip: this.skipNumber
                    }].filter((e => null !== e))
                }
                _aggregateValidator(e) {
                    return new We(e, this.invalidArguments)
                }
            }

            function Pe(e) {
                const t = Object.keys(e).map((e => ({
                    [e]: 1
                })));
                return (0, i.isObject)(e._id) ? t.push(function(e) {
                    const t = Object.keys(e),
                        r = t.map((e => ({
                            [e]: `$_id.${e}`
                        })));
                    return Object.assign({}, ...r)
                }(e._id)) : (0, i.isString)(e._id) && "0" !== e._id && t.push({
                    [e._id.substr(1)]: "$_id"
                }), Object.assign({}, ...t)
            }

            function Ce(e, t, r, i) {
                return new Ee({
                    provider: e,
                    collectionName: t,
                    cursor: i,
                    limitNumber: r
                })
            }
            class Te {
                constructor(e) {
                    e && (this._items = e.items, this._hasNext = e.hasNext, this._aggregate = e.aggregate, this._pageSize = e.pageSize, this._cursors = e.cursors, this._createdByCursor = e.createdByCursor)
                }
                get items() {
                    return this._items
                }
                hasNext() {
                    return this._hasNext
                }
                hasPrev() {
                    return fe(this._createdByCursor) || this._cursors ? fe(this.prevCursor) : this._aggregate.skipNumber > 0
                }
                get length() {
                    return this._items.length
                }
                next() {
                    if (!this.hasNext()) return this._rejectNoNextPage();
                    let e;
                    if (fe(this.nextCursor)) e = this._getNewCursorAggregate(this.nextCursor);
                    else {
                        const t = ye(this._aggregate, this.length, !0);
                        e = this._aggregate.skip(t)
                    }
                    return e.run()
                }
                prev() {
                    if (!this.hasPrev()) return this._rejectNoPrevPage();
                    let e;
                    return e = fe(this.prevCursor) ? this._getNewCursorAggregate(this.prevCursor) : this._aggregate.skip(Math.max(0, this._aggregate.skipNumber - this._aggregate.limitNumber)), e.run()
                }
                get nextCursor() {
                    return this._cursors && this._cursors.next
                }
                get prevCursor() {
                    return this._cursors && this._cursors.prev
                }
                _getNewCursorAggregate(e) {
                    const t = this._aggregate;
                    return Ce(t.provider, t.collectionName, t.limitNumber, e)
                }
                _rejectNoPrevPage() {
                    return Promise.reject(k($.noPrevPage(this._aggregate.collectionName)))
                }
                _rejectNoNextPage() {
                    return Promise.reject(k($.noNextPage(this._aggregate.collectionName)))
                }
            }
            const xe = 9007199254740991;
            class We extends M {
                constructor(e, t) {
                    super(t), this.operatorName = e
                }
                filterBuilder(e) {
                    return this.addValidation((() => "FilterBuilder" === e.constructorName), (() => y.filterMustBeBuilder(this.operatorName)))
                }
                filterIsNotSet(e) {
                    return this.addValidation((() => void 0 === e.filterTree), (() => y.filterIsAlreadySet(this.operatorName)))
                }
                havingIsNotSet(e) {
                    return this.addValidation((() => void 0 === e.havingTree), (() => y.filterIsAlreadySet(this.operatorName)))
                }
                groupIsNotSet(e) {
                    return this.addValidation((() => function(e) {
                        return !e || "0" === e._id
                    }(e)), (() => y.groupIsAlreadySet(this.operatorName)))
                }
                _isNumber(e, t) {
                    return this.addValidation((() => (0, i.isNumber)(t)), (() => $.isNumber(this.operatorName, e, t)))
                }
                isPositiveNumber(e) {
                    return this._isNumber("positive", e).addValidation((() => !Number.isNaN(e) && e > 0), (() => $.isPositiveNumber(this.operatorName, e)))
                }
                isNonNegativeNumber(e) {
                    return this._isNumber("non-negative", e).addValidation((() => !Number.isNaN(e) && e >= 0), (() => $.isNonNegativeNumber(this.operatorName, e)))
                }
                isInteger(e) {
                    return this.addValidation((() => !Number.isNaN(e) && Number.isFinite(e) && Number.isInteger(e) && e < xe && e > -9007199254740991), (() => $.isInteger(this.operatorName, e)))
                }
            }
            class ke extends(ge()) {
                _build() {
                    return this.getSortModel()
                }
            }
            class Re {
                constructor(e) {
                    if (!e) return;
                    this._provider = e.provider, this._collectionName = e.collectionName, this._referenceAttribute = e.referenceAttribute, this._holdingItemId = e.holdingItemId, this._items = e.items, this._totalCount = e.totalCount, this._options = e.options;
                    const {
                        skip: t = 0,
                        limit: r
                    } = e.options || {};
                    this._skip = t, this._limit = r, this._cursors = e.cursors, this._createdByCursor = e.createdByCursor, this._hasNext = e.hasNext
                }
                get items() {
                    return this._items
                }
                get totalCount() {
                    return this._totalCount
                }
                get nextCursor() {
                    return this._cursors && this._cursors.next
                }
                get prevCursor() {
                    return this._cursors && this._cursors.prev
                }
                hasNext() {
                    return this._hasNext
                }
                hasPrev() {
                    return fe(this._createdByCursor) || this._cursors ? fe(this.prevCursor) : this._skip > 0
                }
                next() {
                    return this.hasNext() ? fe(this.nextCursor) ? this._getNewCursorQuery(this.nextCursor)._fetch().then((e => e._withTotalCount(this._totalCount))) : this._withChangedSkip(!0)._fetch() : this._rejectNoNextPage()
                }
                prev() {
                    return this.hasPrev() ? fe(this.prevCursor) ? this._getNewCursorQuery(this.prevCursor)._fetch().then((e => e._withTotalCount(this._totalCount))) : this._withChangedSkip(!1)._fetch() : this._rejectNoPrevPage()
                }
                _rejectNoPrevPage() {
                    return Promise.reject(k($.noPrevPage(this._collectionName)))
                }
                _rejectNoNextPage() {
                    return Promise.reject(k($.noNextPage(this._collectionName)))
                }
                _withChangedSkip(e) {
                    const t = ye({
                        skipNumber: this._skip,
                        limitNumber: this._limit
                    }, this._items.length, e);
                    return Fe({
                        items: this._items,
                        totalCount: this._totalCount,
                        pagingMetadata: new ve({
                            total: this._totalCount
                        })
                    }, this._provider, this._collectionName, this._holdingItemId, this._referenceAttribute, { ...this._options,
                        skip: t,
                        limit: this._limit
                    })
                }
                _getNewCursorQuery(e) {
                    return Fe({}, this._provider, this._collectionName, "", this._referenceAttribute, {
                        cursor: e,
                        limit: this._limit,
                        omitTotalCount: !0
                    })
                }
                _fetch() {
                    return this._provider.queryReferenced(this._collectionName, this._holdingItemId, this._referenceAttribute, this._options).then((e => Fe(e, this._provider, this._collectionName, this._holdingItemId, this._referenceAttribute, this._options)))
                }
                _withTotalCount(e) {
                    return this._totalCount = e, this
                }
            }

            function Fe(e, t, r, i, n, s) {
                const {
                    items: o,
                    totalCount: a,
                    pagingMetadata: l
                } = e, {
                    total: c,
                    cursors: u,
                    hasNext: d = !1
                } = l || new ve;
                return new Re({
                    provider: t,
                    collectionName: r,
                    referenceAttribute: n,
                    holdingItemId: i,
                    items: o,
                    totalCount: c || a,
                    options: s,
                    cursors: u,
                    createdByCursor: s ? .cursor,
                    hasNext: d
                })
            }

            function qe(e, t) {
                if (!e) return !1;
                if (Array.isArray(e)) return e.some((e => qe(e, t)));
                if ("object" == typeof e) {
                    return Object.keys(e).some((r => t(r) || qe(e[r], t)))
                }
                return !1
            }
            class Ve {
                constructor(e) {
                    this.get = Me(((e, t, r, i) => z().arity("get", e, 2, 3).collectionName(t).itemId(r).options(i).validateAndReject().then((() => this.provider.get(t, r, i))).then(Ue))), this.insert = Me(((e, t, r, i) => z().arity("insert", e, 2, 3).validateAndReject().then((() => Be(this.provider, "insert")(t, r, i))))), this.query = e => be(this.provider, e), this.filter = () => pe(), this.sort = () => new ke(void 0), this.find = (e, t, r, i, n, s, o, a) => {
                        const l = be(this.provider, e);
                        l.filterTree = t, l.orderBy = r, l.skipNumber = i, l.limitNumber = n, l.included = o;
                        const c = { ...s,
                            omitTotalCount: a
                        };
                        return l.find(c)
                    }, this.remove = Me(((e, t, r, i) => z().arity("remove", e, 2, 3).collectionName(t).itemId(r).options(i).validateAndReject().then((() => this.provider.remove(t, r, i))).then(Ue))), this.truncate = Me(((e, t, r) => z().arity("truncate", e, 1, 2).collectionName(t).options(r).validateAndReject().then((() => this.provider.truncate(t, r))).then(Ue))), this.bulkRemove = Me(((e, t, r, i) => z().arity("bulkRemove", e, 2, 3).collectionName(t).itemIds(r, t).options(i).validateAndReject().then((() => this.provider.bulkRemove(t, r, i))).then(Ue).then((e => {
                        const t = e.errors.map((e => new F(e.message, e.code, e.item, e.name, e.originalIndex)));
                        return { ...e,
                            errors: t
                        }
                    })))), this.save = Me(((e, t, r, i) => z().arity("save", e, 2, 3).validateAndReject().then((() => Be(this.provider, "save")(t, r, i))))), this.update = Me(((e, t, r, i) => z().arity("update", e, 2, 3).validateAndReject().then((() => Be(this.provider, "update")(t, r, i))))), this.fetch = Me(((e, t, r, i, n) => z().arity("fetch", e, 3, 4).isNonEmptyString(r, "cursor").validateAndReject().then((() => this.provider.find(t, void 0, void 0, void 0, i, n, void 0, !0, r))).then((e => function(e, t, r, i, n, s) {
                        const {
                            items: o,
                            totalCount: a,
                            partialIncludes: l,
                            pagingMetadata: c
                        } = e, {
                            cursors: u,
                            hasNext: d = !1
                        } = c || new ve, h = be(t, r).limit(i), p = fe(u ? .next) || fe(u ? .prev) ? { ...n,
                            omitTotalCount: !0
                        } : n;
                        return new Ae({
                            createdByCursor: s,
                            items: o,
                            totalCount: a,
                            partialIncludes: l,
                            cursors: u,
                            query: h,
                            pagingFunction() {
                                return this.find(p)
                            },
                            hasNext: d
                        })
                    }(e, this.provider, t, i, n))))), this.fetchReferenced = Me(((e, t, r, i, n) => z().arity("fetchReferenced", e, 3, 4).isNonEmptyString(r, "cursor").validateAndReject().then((() => {
                        const e = { ...n
                        };
                        return e.limit = i, e.cursor = r, e.omitTotalCount = !0, this.provider.queryReferenced(t, void 0, void 0, e).then((r => Fe(r, this.provider, t, void 0, void 0, e)))
                    })))), this.fetchAggregate = Me(((e, t, r, i, n) => z().arity("fetchAggregate", e, 3, 4).isNonEmptyString(r, "cursor").validateAndReject().then((() => Ce(this.provider, t, i, r).run(n))))), this.queryReferenced = Me(((e, t, r, i, n) => z().arity("queryReferenced", e, 3, 4).referenceParameter(r).validateAndReject().then((() => {
                        const e = Ge(r),
                            s = n || {};
                        return this.provider.queryReferenced(t, e, i, s).then((r => Fe(r, this.provider, t, e, i, n)))
                    })))), this.insertReference = Me(((e, t, r, n, s, o) => {
                        let a, l, c;
                        return (0, i.isArray)(r) ? (l = r, a = n, c = () => z().arity("insertReference", e, 2, 3).references(l).validateAndReject()) : (l = ze(s).map((e => ({
                            relationshipName: r,
                            left: n,
                            right: e
                        }))), a = o, c = () => z().arity("insertReference", e, 4, 5).references(l).validateAndReject()), c().then((() => this.provider.insertReferences(t, (e => e.map((e => ({
                            relationshipName: e.relationshipName,
                            left: Ge(e.left),
                            right: Ge(e.right)
                        }))))(l), a)))
                    })), this.replaceReferences = Me(((e, t, r, i, n, s) => (n = ze(n).map(Ge), i = Ge(i), z().arity("replaceReferences", e, 4, 5).referenceParameter(i).referenceParameters(n).validateAndReject().then((() => this.provider.replaceReferences(t, {
                        relationshipName: r,
                        left: i
                    }, n.map((e => ({
                        relationshipName: r,
                        right: e,
                        left: i
                    }))), s)))))), this.removeReference = Me(((e, t, r, i, n, s) => (n = ze(n).map(Ge), i = Ge(i), z().arity("removeReference", e, 4, 5).referenceParameter(i).referenceRemoveParameters(n).validateAndReject().then((() => 1 === n.length ? this.provider.removeReference(t, r, i, n[0], s) : this.provider.removeReferences(t, n.map((e => ({
                        relationshipName: r,
                        right: e,
                        left: i
                    }))), s)))))), this.isReferenced = Me(((e, t, r, i, n, s) => z().arity("isReferenced", e, 4, 5).referenceParameter(i).referenceParameter(n).validateAndReject().then((() => this.provider.isReferenced(t, r, Ge(i), Ge(n), s))))), this.bulkInsert = Me(((e, t, r, i) => z().arity("bulkInsert", e, 2, 3).validateAndReject().then((() => this.provider.bulkInsert(t, r, i))).then((e => {
                        const t = e.errors.map((e => new F(e.message, e.code, e.item, e.name, e.originalIndex)));
                        return { ...e,
                            errors: t
                        }
                    })))), this.bulkSave = Me(((e, t, r, i) => z().arity("bulkSave", e, 2, 3).validateAndReject().then((() => this.provider.bulkSave(t, r, i))).then((e => {
                        const t = e.errors.map((e => new F(e.message, e.code, e.item, e.name, e.originalIndex)));
                        return { ...e,
                            errors: t
                        }
                    })))), this.bulkUpdate = Me(((e, t, r, i) => z().arity("bulkUpdate", e, 2, 3).validateAndReject().then((() => this.provider.bulkUpdate(t, r, i))).then((e => {
                        const t = e.errors.map((e => new F(e.message, e.code, e.item, e.name, e.originalIndex)));
                        return { ...e,
                            errors: t
                        }
                    })))), this.getSchema = () => this.provider.getSchema(), this.group = (...e) => we(...e), this.aggregate = e => function(e, t) {
                        return new Ee({
                            provider: e,
                            collectionName: t
                        })
                    }(this.provider, e), this.provider = e
                }
                get wixData() {
                    return this
                }
            }

            function Me(e) {
                return function(...t) {
                    return e(arguments, ...t)
                }
            }

            function Be(e, t, r = !1) {
                return (i, n, s) => {
                    return z().collectionName(i).item(n, i, r).options(s).validateAndReject().then((() => function(e) {
                        const t = qe(e, (e => e.startsWith("$"))),
                            r = qe(e, (e => e.includes(".")));
                        t && console.error("Data inserted contains field name prefixed with symbol '$'. It is not recommended to use such field names as it will not work with some data operations.");
                        r && console.warn("Data inserted contains field name containing symbol '.'. It is not recommended to use such field names as it will not work with some data operations.")
                    }(n))).then((() => e[t](i, n, s))).then(Ue).then((o = n, function(e) {
                        if (e) {
                            for (const t in e) e.hasOwnProperty(t) && (o.hasOwnProperty(t) && !0 !== Object.getOwnPropertyDescriptor(o, t) ? .writable || (o[t] = e[t]));
                            for (const t in o) e.hasOwnProperty(t) || delete o[t];
                            return o
                        }
                    }));
                    var o
                }
            }

            function Ue(e) {
                return e && e.hasOwnProperty("item") ? e.item : e
            }

            function ze(e) {
                return (0, i.isArray)(e) ? e : [e]
            }

            function Ge(e) {
                return (0, i.isObject)(e) ? e._id : e
            }
            const {
                getSchemaNamespace: Qe
            } = r(88794);

            function Le(e) {
                return "WDE0020" === e || "WDE0024" === e ? x.ValidationError : "WDE0025" === e ? x.SchemaDoesNotExist : "WDE0026" === e ? x.CollectionDeleted : "WDE0027" === e ? x.PermissionDenied : "WDE0052" === e ? x.SiteInTemplateMode : "WDE0073" === e ? x.ItemDoesNotExist : "WDE0074" === e ? x.ItemAlreadyExists : "WDE0022" === e || "WDE0007" === e ? x.ValidationError : e
            }
            const He = "WDE0078",
                Je = "WDE0109",
                Xe = "WDE0080",
                Ze = e => t => e("platformized-data-response", {
                    requestId: t.headers ? .["x-wix-request-id"]
                })((() => (0, i.parseDates)(t.data))),
                Ye = e => t => e("wix-data-error-response", {
                    responseData: t ? .response ? .data,
                    status: t ? .response ? .status,
                    requestId: t ? .response ? .headers ? .["x-wix-request-id"],
                    error: t ? .response ? void 0 : t
                })((() => Promise.resolve())).then((() => {
                    if (function(e) {
                            return 413 === e ? .response ? .status
                        }(t)) return W(T(), Je);
                    const e = t ? .response ? .data;
                    return Ke(e) ? function(e) {
                        const t = e.details.applicationError.data;
                        if (t ? .jsErrorValue) {
                            const {
                                name: e,
                                message: r,
                                code: i
                            } = t.jsErrorValue, n = new Error(r);
                            return n.name = e, n.code = i, n
                        }
                        return t ? .value
                    }(e) : function(e) {
                        return e ? .details ? .applicationError
                    }(e) ? et(e) : function(e) {
                        return e ? .details ? .validationError
                    }(e) ? function(e) {
                        const t = (e.details.validationError.fieldViolations || []).map((e => `${e.field}: ${e.description}`)),
                            r = [e.message, ...t].join("\n");
                        return W(r, Xe, e.details)
                    }(e) : W(P("Unknown error."), x.UnknownError)
                })).then((e => Promise.reject(e)));

            function Ke(e) {
                return e ? .details ? .applicationError ? .code === He
            }
            const et = e => {
                const t = Le(e.details.applicationError.code);
                return W(e.details.applicationError.description, t, e.details)
            };
            const tt = e => t => rt(e)({
                    message: t.itemMetadata.error.description,
                    details: {
                        applicationError: {
                            code: t.itemMetadata.error.code,
                            description: t.itemMetadata.error.description
                        }
                    },
                    originalIndex: t.itemMetadata.originalIndex
                }),
                rt = e => t => {
                    const {
                        message: r,
                        code: i,
                        name: n
                    } = function(e) {
                        const t = e.details ? .applicationError;
                        if (Ke(e)) {
                            const e = t.data ? .jsErrorValue;
                            if (e) return {
                                message: e.message,
                                code: e.code,
                                name: e.name
                            };
                            const r = t.data ? .value;
                            return "string" == typeof r ? {
                                message: r
                            } : {}
                        }
                        return {
                            code: Le(t ? .code) || x.UnknownError,
                            message: t ? .description || e.message,
                            name: "Error"
                        }
                    }(t);
                    return {
                        message: r,
                        code: i,
                        name: n,
                        originalIndex: t.originalIndex,
                        item: e[t.originalIndex]
                    }
                };
            const it = () => e => e();

            function nt(e) {
                const t = "object" == typeof e ? Object.keys(e).filter((t => "object" == typeof e[t] && "_id" !== t)).map((t => {
                        const r = e[t],
                            i = (e => {
                                switch (Object.keys(e)[0]) {
                                    case "$sum":
                                        return "sum";
                                    case "$min":
                                        return "min";
                                    case "$avg":
                                        return "average";
                                    case "$max":
                                        return "max";
                                    default:
                                        return ""
                                }
                            })(r),
                            n = (e => {
                                const t = Object.values(e)[0];
                                return "string" == typeof t && t.startsWith("$") ? t.substring(1) : t
                            })(r),
                            s = {
                                resultFieldName: t
                            };
                        return "sum" === i && 1 === n ? s.itemCount = {} : s[i] = {
                            itemFieldName: n
                        }, s
                    })) : [],
                    r = {
                        groupingFields: (e => "object" == typeof e ? "object" == typeof e._id ? Object.keys(e._id) : "0" === e._id ? [] : [e._id.substring(1)] : [])(e),
                        operations: t
                    };
                return r
            }
            const st = e => "object" == typeof e && null !== e && "get" in e && "function" == typeof e.get;
            class ot {
                constructor({
                    cloudDataUrl: e = "/_api/cloud-data",
                    gridAppId: t,
                    segment: r,
                    httpClient: i,
                    authHeader: n,
                    traceWith: s = it,
                    allowGetRequests: o = !1,
                    shouldUseDataItemService: a = Promise.resolve(!1)
                }) {
                    this.cloudDataUrl = e, this.gridAppId = t, this.segment = r, this.httpClientProvider = "function" == typeof i ? i : () => i, this.traceWith = s, this.authHeader = n, this.allowGetRequests = o, this.shouldUseDataItemService = a
                }
                _unwarpDataItems(e) {
                    return e.map((e => e.data))
                }
                _unwrapDataItem(e) {
                    return e && e.hasOwnProperty("dataItem") && e.dataItem.hasOwnProperty("data") ? {
                        item: e.dataItem.data
                    } : e
                }
                insert(e, t, r) {
                    return this._traceWith("platformized-provider-insert", {
                        collectionName: e
                    })((() => z().collectionName(e).item(t, e, !1).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items", {
                        dataCollectionId: e,
                        dataItem: {
                            id: t._id,
                            dataCollectionId: e,
                            data: t
                        },
                        includeReferencedItems: r && r.includeReferences,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, i).then(this._unwrapDataItem) : this._call("/v1/wix-data/collections/insert", {
                        collectionName: e,
                        item: t,
                        options: this._optionsWithPlugins(r)
                    })))))
                }
                update(e, t, r) {
                    return this._traceWith("platformized-provider-update", {
                        collectionName: e
                    })((() => z().collectionName(e).item(t, e, !1).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items/update", {
                        dataCollectionId: e,
                        dataItem: {
                            id: t._id,
                            dataCollectionId: e,
                            data: t
                        },
                        includeReferencedItems: r && r.includeReferences,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, i).then(this._unwrapDataItem) : this._call("/v1/wix-data/collections/update", {
                        collectionName: e,
                        item: t,
                        options: this._optionsWithPlugins(r)
                    })))))
                }
                save(e, t, r) {
                    return this._traceWith("platformized-provider-save", {
                        collectionName: e
                    })((() => z().collectionName(e).item(t, e, !1).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items/save", {
                        dataCollectionId: e,
                        dataItem: {
                            id: t._id,
                            dataCollectionId: e,
                            data: t
                        },
                        includeReferencedItems: r && r.includeReferences,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, i).then(this._unwrapDataItem) : this._call("/v1/wix-data/collections/save", {
                        collectionName: e,
                        item: t,
                        options: this._optionsWithPlugins(r)
                    })))))
                }
                truncate(e, t) {
                    return this._traceWith("platformized-provider-truncate", {
                        collectionName: e
                    })((() => z().collectionName(e).truncateOptions(t).validateAndReject().then((() => this.shouldUseDataItemService)).then((r => r ? this._call("/v2/items/truncate", {
                        dataCollectionId: e,
                        options: this._optionsWithPluginsItemService(t)
                    }, !1, r) : this._call("/v1/wix-data/collections/truncate", {
                        collectionName: e,
                        options: this._optionsWithPlugins(t)
                    }))).then((() => Promise.resolve(null)))))
                }
                remove(e, t, r) {
                    return this._traceWith("platformized-provider-remove", {
                        collectionName: e
                    })((() => z().collectionName(e).itemId(t).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items/remove", {
                        dataCollectionId: e,
                        dataItemId: t,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, i).then(this._unwrapDataItem) : this._call("/v1/wix-data/collections/remove", {
                        collectionName: e,
                        itemId: t,
                        options: this._optionsWithPlugins(r)
                    }))).catch((e => e && e.code === x.ItemDoesNotExist ? Promise.resolve(null) : Promise.reject(e)))))
                }
                bulkRemove(e, t, r) {
                    return this._traceWith("platformized-provider-bulk-remove", {
                        collectionName: e
                    })((() => z().collectionName(e).itemIds(t, e).bulkRemoveOptions(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => 0 === t.length ? {
                        removedItemIds: [],
                        removed: 0,
                        skipped: 0,
                        errors: []
                    } : i ? this._call("/v2/bulk/items/remove", {
                        dataCollectionId: e,
                        dataItemIds: t,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, !0).then((({
                        results: e
                    }) => {
                        const r = e.filter((e => e.itemMetadata.success)),
                            i = e.filter((e => !e.itemMetadata.success && "WDE0073" !== e.itemMetadata.error.code)),
                            n = r.map((e => e.itemMetadata.id));
                        return {
                            removedItemIds: n,
                            removed: n.length,
                            skipped: t.length - n.length - i.length,
                            errors: i.map(tt(t))
                        }
                    })) : this._call("/v1/wix-data/collections/bulk-remove", {
                        collectionName: e,
                        entries: t.map((e => ({
                            itemId: e
                        }))),
                        options: this._optionsWithPlugins(r)
                    }).then((e => {
                        const {
                            removedItemIds: r,
                            errors: i
                        } = e;
                        return {
                            removedItemIds: r,
                            removed: r.length,
                            skipped: t.length - r.length - i.length,
                            errors: i.map(rt(t))
                        }
                    })))).catch((e => e && e.code === x.ItemDoesNotExist ? Promise.resolve(null) : Promise.reject(e)))))
                }
                get(e, t, r) {
                    return this._traceWith("platformized-provider-get", {
                        collectionName: e,
                        itemId: t
                    })((() => z().collectionName(e).itemId(t).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items/get", {
                        dataCollectionId: e,
                        dataItemId: t,
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, i).then(this._unwrapDataItem) : this._call("/v1/wix-data/collections/get", {
                        collectionName: e,
                        itemId: t,
                        options: this._optionsWithPlugins(r)
                    }))).catch((e => e && e.code === x.ItemDoesNotExist ? Promise.resolve(null) : Promise.reject(e)))))
                }
                find(e, t, r, n, s, o, a, l, c, u) {
                    return this._traceWith("platformized-provider-find", {
                        collectionName: e
                    })((() => z().collectionName(e).options(o).validateAndReject().then((() => this._validateOrderBy(e, r))).then((() => this._validateFilter(e, t))).then((() => this.shouldUseDataItemService)).then((d => {
                        const h = this._getDataQuery(t, r, s, n, c, u);
                        return d ? this._call("/v2/items/query", {
                            dataCollectionId: e,
                            query: h,
                            options: this._optionsWithPluginsItemService(o),
                            includeReferencedItems: a,
                            returnTotalCount: !l
                        }, !0, !0).then((e => {
                            const {
                                dataItems: t,
                                pagingMetadata: r
                            } = e, n = this._unwarpDataItems(t), s = !!n.find((e => !(!(0, i.isArray)(a) || !a.find((t => {
                                const r = e[t];
                                return (0, i.isArray)(r) && r.length >= 50
                            })))));
                            return {
                                items: n,
                                partialIncludes: s,
                                totalCount: r.total,
                                pagingMetadata: r
                            }
                        })) : this._call("/v1/wix-data/collections/query", {
                            collectionName: e,
                            dataQuery: h,
                            options: this._optionsWithPlugins(o),
                            includeReferencedItems: a,
                            omitTotalCount: l
                        }, !0).then((({
                            items: e,
                            partialIncludes: t,
                            pagingMetadata: r
                        }) => ({
                            items: e,
                            partialIncludes: t,
                            totalCount: r.total,
                            pagingMetadata: r
                        })))
                    }))))
                }
                runAggregate(e, t, r, n, s) {
                    return this._traceWith("platformized-provider-aggregate", {
                        collectionName: e
                    })((() => z().collectionName(e).options(n).validateAndReject().then((() => this.shouldUseDataItemService)).then((o => {
                        const a = (0, i.toPlatformizedAggregate)(t);
                        return o ? this._call("/v2/items/aggregate", {
                            dataCollectionId: e,
                            initialFilter: a.preFilteringStep,
                            aggregation: nt(a.processingStep),
                            finalFilter: a.postFilteringStep,
                            sort: this._platformizedSort(t),
                            options: this._optionsWithPluginsItemService(n),
                            ...this._getAggregatePaging(t, r, s)
                        }, !0, !0).then((e => {
                            const {
                                results: t,
                                pagingMetadata: {
                                    cursors: r,
                                    hasNext: i
                                }
                            } = e;
                            return {
                                items: t.map((e => {
                                    if ("object" == typeof e._id && 1 === Object.keys(e._id).length) {
                                        const t = e._id[Object.keys(e._id)[0]];
                                        e._id = t
                                    }
                                    return e
                                })),
                                hasNext: i,
                                cursors: r
                            }
                        })) : this._call("/v1/wix-data/collections/aggregate", {
                            collectionName: e,
                            initialFilter: a.preFilteringStep,
                            aggregation: a.processingStep,
                            finalFilter: a.postFilteringStep,
                            sort: this._platformizedSort(t),
                            options: this._optionsWithPlugins(n),
                            ...this._getAggregatePaging(t, r, s)
                        }).then((e => {
                            const {
                                items: t,
                                pagingMetadata: {
                                    cursors: r,
                                    hasNext: i
                                }
                            } = e;
                            return {
                                items: t,
                                hasNext: i,
                                cursors: r
                            }
                        }))
                    }))))
                }
                _optionsWithPluginsItemService(e) {
                    const t = e || {};
                    return t.showDrafts ? { ...t,
                        publishPluginOptions: {
                            showDraftItems: !0
                        }
                    } : t
                }
                _optionsWithPlugins(e) {
                    const t = e || {};
                    return t.showDrafts ? { ...t,
                        pluginOptions: {
                            showDrafts: !0
                        }
                    } : t
                }
                _platformizedSort(e) {
                    const t = e.find((e => e.hasOwnProperty("$sort")));
                    if (!t) return;
                    return t.$sort.map((e => {
                        const [t, r] = Object.entries(e)[0];
                        return {
                            fieldName: t,
                            order: "asc" === r ? 0 : 1
                        }
                    }))
                }
                _getDataQuery(e, t, r, i, n, s) {
                    return {
                        filter: e,
                        sort: t ? this._mapOrderToSort(t) : void 0,
                        ...this._getPaging(r, i, n),
                        fields: s
                    }
                }
                _getAggregatePaging(e, t, r) {
                    const i = e.find((e => e.hasOwnProperty("$skip"))),
                        n = void 0 !== i ? i.$skip : void 0;
                    return this._getPaging(t, n, r)
                }
                _getPaging(e, t, r) {
                    if (r && t > 0) throw W(C(), x.ValidationError);
                    return r ? {
                        cursorPaging: {
                            limit: e,
                            cursor: r
                        }
                    } : {
                        paging: {
                            offset: t,
                            limit: e
                        }
                    }
                }
                count(e, t, r) {
                    return this._traceWith("platformized-provider-count", {
                        collectionName: e
                    })((() => z().collectionName(e).options(r).validateAndReject().then((() => this._validateFilter(e, t))).then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/items/count", {
                        dataCollectionId: e,
                        filter: t,
                        options: this._optionsWithPluginsItemService(r)
                    }, !0, !0) : this._call("/v1/wix-data/collections/count", {
                        collectionName: e,
                        filter: t,
                        options: this._optionsWithPlugins(r)
                    })))))
                }
                _sortingFromOrder(e, t) {
                    const r = e.find((e => e.hasOwnProperty(t))),
                        i = r && r.hasOwnProperty(t) ? r[t] : void 0;
                    return i ? i.toUpperCase() : i
                }
                distinct(e, t, r, i, n, s, o, a, l, c) {
                    return this._traceWith("platformized-provider-distinct", {
                        collectionName: e
                    })((() => z().collectionName(e).options(o).validateAndReject().then((() => this._validateOrderBy(e, r))).then((() => this._validateFilter(e, t))).then((() => this.shouldUseDataItemService)).then((u => {
                        const d = this._getDataQuery(t, r, s, n, a, l);
                        return u ? this._call("/v2/items/query-distinct-values", {
                            dataCollectionId: e,
                            fieldName: i,
                            filter: d.filter,
                            order: this._sortingFromOrder(r, i),
                            options: this._optionsWithPluginsItemService(o),
                            paging: d.paging,
                            cursorPaging: d.cursorPaging,
                            returnTotalCount: !c
                        }, !0, !0).then((({
                            distinctValues: e,
                            pagingMetadata: t
                        }) => ({
                            items: e,
                            totalCount: t.total,
                            pagingMetadata: t
                        }))) : this._call("/v1/wix-data/collections/distinct", {
                            collectionName: e,
                            dataQuery: d,
                            propertyName: i,
                            options: this._optionsWithPlugins(o),
                            omitTotalCount: c
                        }).then((({
                            items: e,
                            pagingMetadata: t
                        }) => ({
                            items: e,
                            totalCount: t.total,
                            pagingMetadata: t
                        })))
                    }))))
                }
                bulkInsert(e, t, r) {
                    return this._traceWith("platformized-provider-bulk-insert", {
                        collectionName: e
                    })((() => {
                        const i = (r || {}).overrideExisting;
                        return z().collectionName(e).items(t, e).bulkInsertOptions(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((n => {
                            if (0 === t.length) return {
                                insertedItemIds: [],
                                inserted: 0,
                                errors: [],
                                skipped: 0,
                                updated: 0
                            };
                            if (n) {
                                const s = i ? "/v2/bulk/items/save" : "/v2/bulk/items/insert";
                                return this._call(s, {
                                    dataCollectionId: e,
                                    dataItems: t.map((t => ({
                                        id: t._id,
                                        dataCollectionId: e,
                                        data: t
                                    }))),
                                    options: this._optionsWithPluginsItemService(r)
                                }, !1, n).then((({
                                    results: e
                                }) => {
                                    const r = e.filter((e => e.itemMetadata.success)),
                                        n = r.map((e => e.itemMetadata.id)),
                                        s = r.filter((e => "INSERT" === e.action)).length,
                                        o = r.filter((e => "UPDATE" === e.action)).length,
                                        a = e.filter((e => !e.itemMetadata.success && "WDE0074" !== e.itemMetadata.error.code));
                                    return {
                                        insertedItemIds: n,
                                        inserted: s,
                                        skipped: i ? 0 : t.length - n.length - a.length,
                                        updated: o,
                                        errors: a.map(tt(t))
                                    }
                                }))
                            }
                            return this._call("/v1/wix-data/collections/bulk-insert", {
                                collectionName: e,
                                items: t,
                                options: this._optionsWithPlugins(r)
                            }).then((e => {
                                const {
                                    insertedItemIds: r,
                                    errors: n
                                } = e;
                                return {
                                    insertedItemIds: r,
                                    inserted: r.length,
                                    skipped: i ? 0 : t.length - r.length - n.length,
                                    updated: i ? t.length - r.length - n.length : 0,
                                    errors: n.map(rt(t))
                                }
                            }))
                        }))
                    }))
                }
                bulkSave(e, t, r) {
                    return this._traceWith("platformized-provider-bulk-save", {
                        collectionName: e
                    })((() => z().collectionName(e).items(t, e).bulkInsertOptions(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => 0 === t.length ? {
                        insertedItemIds: [],
                        updatedItemIds: [],
                        inserted: 0,
                        updated: 0,
                        skipped: 0,
                        errors: []
                    } : i ? this._call("/v2/bulk/items/save", {
                        dataCollectionId: e,
                        dataItems: t.map((t => ({
                            id: t._id,
                            dataCollectionId: e,
                            data: t
                        }))),
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, !0).then((({
                        results: e
                    }) => {
                        const r = e.filter((e => e.itemMetadata.success)),
                            i = r.filter((e => "INSERT" === e.action)),
                            n = r.filter((e => "UPDATE" === e.action)),
                            s = i.map((e => e.itemMetadata.id)),
                            o = n.map((e => e.itemMetadata.id)),
                            a = e.filter((e => !e.itemMetadata.success));
                        return {
                            insertedItemIds: s,
                            updatedItemIds: o,
                            inserted: i.length,
                            skipped: t.length - s.length - o.length - a.length,
                            updated: n.length,
                            errors: a.map(tt(t))
                        }
                    })) : this._call("/v1/wix-data/collections/bulk-save", {
                        collectionName: e,
                        items: t,
                        options: this._optionsWithPlugins(r)
                    }).then((e => {
                        const {
                            insertedItemIds: r,
                            updatedItemIds: i,
                            errors: n
                        } = e;
                        return {
                            insertedItemIds: r,
                            updatedItemIds: i,
                            inserted: r.length,
                            skipped: t.length - r.length - i.length - n.length,
                            updated: i.length,
                            errors: n.map(rt(t))
                        }
                    }))))))
                }
                bulkUpdate(e, t, r) {
                    return this._traceWith("platformized-provider-bulk-update", {
                        collectionName: e
                    })((() => z().collectionName(e).items(t, e).bulkUpdateOptions(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => 0 === t.length ? {
                        updatedItemIds: [],
                        inserted: 0,
                        skipped: 0,
                        updated: 0,
                        errors: []
                    } : i ? this._call("/v2/bulk/items/update", {
                        dataCollectionId: e,
                        dataItems: t.map((t => ({
                            id: t._id,
                            dataCollectionId: e,
                            data: t
                        }))),
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, !0).then((({
                        results: e
                    }) => {
                        const r = e.filter((e => e.itemMetadata.success)).filter((e => "UPDATE" === e.action)),
                            i = r.map((e => e.itemMetadata.id)),
                            n = e.filter((e => !e.itemMetadata.success && "WDE0073" != e.itemMetadata.error.code));
                        return {
                            updatedItemIds: i,
                            inserted: 0,
                            skipped: t.length - i.length - n.length,
                            updated: r.length,
                            errors: n.map(tt(t))
                        }
                    })) : this._call("/v1/wix-data/collections/bulk-update", {
                        collectionName: e,
                        items: t,
                        options: this._optionsWithPlugins(r)
                    }).then((e => {
                        const {
                            updatedItemIds: r,
                            errors: i
                        } = e;
                        return {
                            updatedItemIds: r,
                            inserted: 0,
                            skipped: t.length - r.length - i.length,
                            updated: r.length,
                            errors: i.map(rt(t))
                        }
                    }))))))
                }
                queryReferenced(e, t, r, i) {
                    return this._traceWith("platformized-provider-query-referenced", {
                        collectionName: e,
                        order: i.order,
                        skip: i.skip,
                        limit: i.limit,
                        cursorExists: i.cursor ? "true" : "false"
                    })((() => {
                        const n = ((i = i || {}).order || "ASC").toUpperCase(),
                            s = i.skip || 0,
                            o = i.limit || 50,
                            a = i.cursor,
                            l = i.omitTotalCount || !1;
                        return z().collectionName(e).options(i).validateAndReject().then((() => this.shouldUseDataItemService)).then((c => c ? this._call("/v2/items/query-referenced", {
                            dataCollectionId: e,
                            referringItemId: t,
                            referringItemFieldName: r,
                            order: n,
                            ...this._getPaging(o, s, a),
                            returnTotalCount: !l,
                            option: this._optionsWithPluginsItemService(i)
                        }, !0, !0).then((({
                            results: e,
                            pagingMetadata: t
                        }) => ({
                            items: e.map((e => e.dataItem.data)),
                            totalCount: t.total,
                            pagingMetadata: t
                        }))) : this._call("/v1/wix-data/collections/query-referenced", {
                            collectionName: e,
                            propertyName: r,
                            referringItemId: t,
                            order: n,
                            ...this._getPaging(o, s, a),
                            omitTotalCount: l,
                            options: this._optionsWithPlugins(i)
                        }).then((({
                            items: e,
                            pagingMetadata: t
                        }) => ({
                            items: e,
                            totalCount: t.total,
                            pagingMetadata: t
                        })))))
                    }))
                }
                insertReference(e, t, r, i, n) {
                    return this._traceWith("platformized-provider-insert-reference", {
                        collectionName: e
                    })((() => this.insertReferences(e, [{
                        relationshipName: t,
                        left: r,
                        right: i
                    }], n)))
                }
                insertReferences(e, t, r) {
                    return this._traceWith("platformized-provider-insert-references", {
                        collectionName: e
                    })((() => z().collectionName(e).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => {
                        if (i) {
                            const i = t.map((({
                                relationshipName: e,
                                left: t,
                                right: r
                            }) => ({
                                referringItemFieldName: e,
                                referringItemId: t,
                                referencedItemId: r
                            })));
                            return this._call("/v2/bulk/items/insert-references", {
                                dataCollectionId: e,
                                dataItemReferences: i,
                                options: this._optionsWithPluginsItemService(r)
                            }, !1, !0)
                        }
                        return this._call("/v1/wix-data/collections/bulk-insert-references", {
                            collectionName: e,
                            references: t.map((({
                                relationshipName: e,
                                left: t,
                                right: r
                            }) => ({
                                propertyName: e,
                                referringItemId: t,
                                referencedItemId: r
                            }))),
                            options: this._optionsWithPlugins(r)
                        })
                    }))))
                }
                replaceReferences(e, t, r, i) {
                    return this._traceWith("platformized-provider-replace-references", {
                        collectionName: e
                    })((() => z().collectionName(e).options(i).validateAndReject().then((() => this.shouldUseDataItemService)).then((n => n ? this._call("/v2/items/replace-references", {
                        dataCollectionId: e,
                        referringItemFieldName: t.relationshipName,
                        referringItemId: t.left,
                        newReferencedItemIds: r.map((({
                            right: e
                        }) => e)),
                        options: this._optionsWithPluginsItemService(i)
                    }, !1, !0) : this._call("/v1/wix-data/collections/bulk-replace-references", {
                        collectionName: e,
                        propertyName: t.relationshipName,
                        referringItemId: t.left,
                        newReferencedItemIds: r.map((({
                            right: e
                        }) => e)),
                        options: this._optionsWithPlugins(i)
                    })))))
                }
                removeReference(e, t, r, i, n) {
                    return this._traceWith("platformized-provider-remove-reference", {
                        collectionName: e
                    })((() => this.removeReferences(e, [{
                        relationshipName: t,
                        left: r,
                        right: i
                    }], n)))
                }
                removeReferences(e, t, r) {
                    return this._traceWith("platformized-provider-remove-references", {
                        collectionName: e
                    })((() => z().collectionName(e).options(r).validateAndReject().then((() => this.shouldUseDataItemService)).then((i => i ? this._call("/v2/bulk/items/remove-references", {
                        dataCollectionId: e,
                        dataItemReferences: t.map((({
                            relationshipName: e,
                            left: t,
                            right: r
                        }) => ({
                            referringItemFieldName: e,
                            referringItemId: t,
                            referencedItemId: r
                        }))),
                        options: this._optionsWithPluginsItemService(r)
                    }, !1, !0) : this._call("/v1/wix-data/collections/bulk-remove-references", {
                        collectionName: e,
                        references: t.map((({
                            relationshipName: e,
                            left: t,
                            right: r
                        }) => ({
                            propertyName: e,
                            referringItemId: t,
                            referencedItemId: r
                        }))),
                        options: this._optionsWithPlugins(r)
                    })))))
                }
                isReferenced(e, t, r, i, n) {
                    return this._traceWith("platformized-provider-is-referenced", {
                        collectionName: e
                    })((() => z().collectionName(e).options(n).validateAndReject().then((() => this.shouldUseDataItemService)).then((s => s ? this._call("/v2/items/is-referenced", {
                        dataCollectionId: e,
                        referringItemFieldName: t,
                        referringItemId: r,
                        referencedItemId: i,
                        options: this._optionsWithPluginsItemService(n)
                    }, !1, !0) : this._call("/v1/wix-data/collections/is-referenced", {
                        collectionName: e,
                        propertyName: t,
                        referringItemId: r,
                        referencedItemId: i,
                        options: this._optionsWithPlugins(n)
                    }))).then((({
                        isReferenced: e
                    }) => e))))
                }
                _mapOrderToSort(e) {
                    return e.flatMap((e => Object.entries(e).map((([e, t]) => ({
                        fieldName: e,
                        order: t.toUpperCase()
                    })))))
                }
                _validateOrderBy(e, t) {
                    const r = e => E.sortModelType(e);
                    if ([null, void 0].includes(t)) return Promise.resolve();
                    if (n = t, !(0, i.isArray)(n)) return Promise.reject(this._validationError(e, [r(t)]));
                    var n;
                    const s = t.flatMap((e => (e => !(0, i.isObject)(e))(e) ? (e => E.sortModelItemType(e))(e) : (e => {
                        const t = Object.values(e);
                        return !(1 === t.length && ("asc" === t[0] || "desc" === t[0]))
                    })(e) ? (e => E.sortModelItem(e))(e) : []));
                    return s.length ? Promise.reject(this._validationError(e, s)) : Promise.resolve()
                }
                _validateFilter(e, t) {
                    const r = w.objectType,
                        n = w.arrayType,
                        s = w.arrayLength,
                        o = w.comparisonOperatorType,
                        a = w.stringOperatorType,
                        l = w.setOperatorItems,
                        c = w.inOperatorItems,
                        u = w.matchesOperatorRequiredProperty,
                        d = w.matchesOperatorIgnoreCase,
                        h = w.matchesOperatorSpecItems,
                        p = w.regexNotAllowed,
                        m = (e, t) => void 0 === t || (0, i.isObject)(t) ? [] : [r(e, t)],
                        g = (e, t) => (0, i.isArray)(t) ? t.flatMap((t => m(e, t))) : [],
                        f = (e, t) => void 0 === t || (0, i.isArray)(t) ? [] : [n(e, t)],
                        v = (e, t) => void 0 === t || (0, i.isString)(t) || (0, i.isNumber)(t) || (0, i.isDate)(t) ? [] : [o(e, t)],
                        y = (e, t) => void 0 === t || (0, i.isString)(t) ? [] : [a(e, t)],
                        _ = (e, t) => (0, i.isArray)(t) ? t.every((e => (0, i.isDate)(e) || (0, i.isString)(e) || (0, i.isNumber)(e))) ? [] : [l(e, t)] : [],
                        N = (e, t, r) => (0, i.isArray)(t) ? t.length === r ? [] : [s(e, r, t)] : [],
                        I = e => {
                            if (!(0, i.isObject)(e)) return [];
                            if (void 0 === e.ignoreCase) return [u("ignoreCase", e)];
                            if (!0 !== e.ignoreCase) return [d(e.ignoreCase)];
                            if (void 0 === e.spec) return [u("spec", e)];
                            if (!(0, i.isArray)(e.spec)) return [n("$matches.spec", e.spec)];
                            const t = e.spec.find((e => !(e => !!(0, i.isObject)(e) && ("anyOf" === e.type && " \t\n-" === e.value || !("literal" !== e.type || !(0, i.isString)(e.value))))(e)));
                            return void 0 !== t ? [h(t)] : []
                        },
                        b = e => {
                            if (!(0, i.isObject)(e)) return [];
                            const {
                                $and: t,
                                $or: r,
                                $not: n,
                                $gt: s,
                                $gte: o,
                                $lt: a,
                                $lte: l,
                                $startsWith: u,
                                $endsWith: d,
                                $contains: h,
                                $hasSome: A,
                                $hasAll: S,
                                $in: $,
                                $matches: j,
                                $regex: O,
                                ...w
                            } = e;
                            let D = [].concat(f("$and", t)).concat(g("Filter Model", t)).concat(f("$or", r)).concat(g("Filter Model", r)).concat(f("$not", n)).concat(g("Filter Model", n)).concat(f("$hasSome", A)).concat(f("$hasAll", S)).concat(f("$in", $)).concat(_("$hasSome", A)).concat(_("$hasAll", S)).concat(v("$gt", s)).concat(v("$gte", o)).concat(v("$lt", a)).concat(v("$lte", l)).concat(y("$startsWith", u)).concat(y("$endsWith", d)).concat(y("$contains", h)).concat(N("$not", n, 1)).concat(N("$in", $, 2)).concat((E = $, (0, i.isArray)(E) ? 2 !== E.length || (0, i.isString)(E[0]) && (0, i.isNumber)(E[1]) ? [] : [c(E)] : [])).concat(m("$matches", j)).concat(I(j)).concat((e => void 0 === e ? [] : [p()])(O));
                            var E;
                            return D.length ? D : (D = [].concat(t ? t.flatMap(b) : []).concat(r ? r.flatMap(b) : []).concat(n ? n.flatMap(b) : []), D.length ? D : Object.values(w).flatMap(b))
                        };
                    if ([null, void 0].includes(t)) return Promise.resolve();
                    if (!(0, i.isObject)(t)) return Promise.reject(this._validationError(e, [r("Filter Model", t)]));
                    const A = b(t);
                    return A.length ? Promise.reject(this._validationError(e, A)) : Promise.resolve()
                }
                _validationError(e, t) {
                    return k($.queryInvalid(e, t))
                }
                _getAuthHeader() {
                    return Promise.resolve(st(this.authHeader) ? this.authHeader.get() : this.authHeader)
                }
                _call(e, t, r = !1, n = !1) {
                    return Promise.all([this._getGridAppId(), this._getAuthHeader()]).then((([s, o]) => this.traceWith("wix-data-api-call", {
                        url: `${this.cloudDataUrl}${e}`,
                        options: JSON.stringify(t.options)
                    })((() => {
                        const a = n ? (0, i.serializeDates)(Object.assign(t, {
                                environment: this.segment.toUpperCase(),
                                appId: s
                            })) : (0, i.serializeDates)(Object.assign(t, {
                                segment: this.segment.toUpperCase(),
                                appId: s
                            })),
                            l = o ? {
                                authorization: o
                            } : {};
                        if (r && this.allowGetRequests) {
                            const r = `${this.cloudDataUrl}${e}?.r=${function(e){"string"!=typeof e&&(e=JSON.stringify(e));const t=(new TextEncoder).encode(e);e=Array.from(t,(e=>String.fromCodePoint(e))).join("");const r={"+":"-","/":"_"};return btoa(e).replace(/[+/]/g,(e=>r[e])).replace(/={1,3}$/,"")}(a)}`;
                            if (r.length <= 2048) return this.httpClientProvider(t.options).get(r, {
                                headers: l
                            }).catch(Ye(this.traceWith)).then(Ze(this.traceWith))
                        }
                        return this.httpClientProvider(t.options).post(`${this.cloudDataUrl}${e}`, a, {
                            headers: l
                        }).catch(Ye(this.traceWith)).then(Ze(this.traceWith))
                    }))))
                }
                _getGridAppId() {
                    return Promise.resolve(st(this.gridAppId) ? this.gridAppId.get() : this.gridAppId)
                }
                _traceWith(e, t) {
                    return r => this._getGridAppId().then((i => this.traceWith(e, {
                        gridAppId: i,
                        segment: this.segment,
                        ...t
                    })(r)))
                }
            }
            const at = () => e => e();

            function lt({
                cloudDataUrl: e = "/_api/cloud-data",
                gridAppId: t,
                segment: r,
                httpClient: i,
                authHeader: n,
                traceWith: s = at,
                allowGetRequests: o = !1,
                shouldUseDataItemService: a = Promise.resolve(!1)
            }) {
                return new Ve(new ot({
                    cloudDataUrl: e,
                    gridAppId: t,
                    segment: r,
                    httpClient: i,
                    authHeader: n,
                    traceWith: s,
                    allowGetRequests: o,
                    shouldUseDataItemService: a
                }))
            }
            const ct = "data";

            function ut({
                featureConfig: e,
                platformUtils: t,
                appEssentials: r,
                platformEnvData: {
                    site: i
                }
            }) {
                const n = {
                        get() {
                            return t.sessionService.getWixCodeInstance()
                        }
                    },
                    s = Boolean(i.experiments["specs.thunderbolt.UseWixDataItemService"]),
                    {
                        gridAppId: o,
                        segment: a,
                        cloudDataUrl: l
                    } = e,
                    {
                        httpClient: c
                    } = r;
                return {
                    [ct]: lt({
                        cloudDataUrl: l,
                        httpClient: c,
                        gridAppId: o,
                        segment: a,
                        authHeader: n,
                        shouldUseDataItemService: Promise.resolve(s)
                    })
                }
            }
        }
    }
]);
//# sourceMappingURL=feature-data-wix-code-sdk.3e539f99.chunk.min.js.map