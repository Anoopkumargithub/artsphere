import {
    __assign,
    __extends
} from "tslib";
import React from 'react';
import {
    GALLERY_CONSTS,
    window,
    utils
} from 'pro-gallery-lib';
import {
    shouldCreateVideoPlaceholder
} from '../itemHelper';
import {
    getStyle
} from './getStyle';
var VideoItem = /** @class */ (function(_super) {
    __extends(VideoItem, _super);

    function VideoItem(props) {
        var _this = _super.call(this, props) || this;
        _this.pause = _this.pause.bind(_this);
        _this.play = _this.play.bind(_this);
        _this.playVideoIfNeeded = _this.playVideoIfNeeded.bind(_this);
        _this.state = {
            playedOnce: false,
            loadVideo: props.loadVideo || props.shouldPlay,
            isPlaying: false,
            shouldPlay: props.shouldPlay,
            reactPlayerLoaded: false,
            vimeoPlayerLoaded: false,
            hlsPlayerLoaded: false,
        };
        return _this;
    }
    VideoItem.prototype.componentDidMount = function() {
        this.dynamiclyImportVideoPlayers();
    };
    VideoItem.prototype.dynamiclyImportVideoPlayers = function() {
        var _this = this;
        if (!(window && window.ReactPlayer)) {
            import (
                /* webpackChunkName: "proGallery_reactPlayer" */
                'react-player').then(function(ReactPlayer) {
                window.ReactPlayer = ReactPlayer.default;
                _this.setState({
                    reactPlayerLoaded: true
                });
                _this.playVideoIfNeeded();
            });
        }
        if (
            //Vimeo player must be loaded by us, problem with requireJS
            !(window && window.Vimeo) &&
            this.props.videoUrl &&
            this.props.videoUrl.includes('vimeo.com')) {
            import (
                /* webpackChunkName: "proGallery_vimeoPlayer" */
                '@vimeo/player').then(function(Player) {
                window.Vimeo = {
                    Player: Player.default
                };
                _this.setState({
                    vimeoPlayerLoaded: true
                });
                _this.playVideoIfNeeded();
            });
        }
        if (
            //Hls player must be loaded by us, problem with requireJS
            !(window && window.Hls) &&
            this.isHLSVideo()) {
            import ( /* webpackChunkName: "proGallery_HlsPlayer" */ 'hls.js').then(function(Player) {
                window.Hls = Player.default;
                _this.setState({
                    hlsPlayerLoaded: true
                });
                _this.playVideoIfNeeded();
            });
        }
    };
    VideoItem.prototype.isHLSVideo = function() {
        return (this.props.videoUrl &&
            (this.props.videoUrl.includes('/hls') ||
                this.props.videoUrl.includes('.m3u8')));
    };
    VideoItem.prototype.shouldUseHlsPlayer = function() {
        return this.isHLSVideo() && !utils.isiOS();
    };
    VideoItem.prototype.shouldForceVideoForHLS = function() {
        return this.isHLSVideo() && utils.isiOS();
    };
    VideoItem.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        if (nextProps.shouldPlay || nextProps.firstUserInteractionExecuted) {
            this.setState({
                loadVideo: true
            });
        }
        if (nextProps.shouldPlay) {
            this.setState({
                shouldPlay: true
            });
        }
        this.playVideoIfNeeded(nextProps);
    };
    VideoItem.prototype.componentDidUpdate = function(prevProps) {
        if (prevProps.activeIndex !== this.props.activeIndex) {
            this.fixIFrameTabIndexIfNeeded();
        }
        if (prevProps.type === 'image' && this.props.type === 'video') {
            this.dynamiclyImportVideoPlayers();
        }
        this.playVideoIfNeeded();
    };
    VideoItem.prototype.play = function() {
        this.props.playVideo(this.props.idx);
    };
    VideoItem.prototype.pause = function() {
        this.props.pauseVideo();
    };
    VideoItem.prototype.playVideoIfNeeded = function(props) {
        if (props === void 0) {
            props = this.props;
        }
        try {
            var playingVideoIdx = props.playingVideoIdx;
            if (playingVideoIdx === this.props.idx && !this.isPlaying) {
                this.videoElement =
                    this.videoElement ||
                    window.document.querySelector("#video-" + this.props.id + " video");
                if (this.videoElement) {
                    this.isPlaying = true;
                    this.videoElement.play();
                    utils.isVerbose() &&
                        console.log('[VIDEO] Playing video #' + this.props.idx, this.videoElement);
                }
            }
        } catch (e) {
            console.error('[VIDEO] Could not play video #' + this.props.idx, this.videoElement, e);
        }
    };
    //-----------------------------------------| UTILS |--------------------------------------------//
    VideoItem.prototype.createPlayerElement = function() {
        var _this = this;
        //video dimensions are for videos in grid fill - placing the video with negative margins to crop into a square
        if (!(window &&
                window.ReactPlayer &&
                (this.state.loadVideo || this.props.playing))) {
            return null;
        }
        var PlayerElement = window.ReactPlayer;
        var isWiderThenContainer = this.props.style.ratio >= this.props.cropRatio;
        // adding 1 pixel to compensate for the difference we have sometimes from layouter in grid fill
        var isCrop = this.props.options.cubeImages && this.props.options.cubeType === 'fill';
        var url = this.props.videoUrl ?
            this.props.videoUrl :
            this.props.createUrl(GALLERY_CONSTS.urlSizes.RESIZED, GALLERY_CONSTS.urlTypes.VIDEO);
        var attributes = {
            controlsList: 'nodownload',
            disablePictureInPicture: true,
            muted: !this.props.options.videoSound,
            preload: 'metadata',
            style: getStyle(isCrop, isWiderThenContainer),
            type: 'video/mp4',
        };
        if (shouldCreateVideoPlaceholder(this.props.options)) {
            attributes.poster = this.props.createUrl(GALLERY_CONSTS.urlSizes.SCALED, GALLERY_CONSTS.urlTypes.HIGH_RES);
        }
        return (React.createElement(PlayerElement, {
            playsinline: true,
            className: 'gallery-item-visible video gallery-item',
            id: "video-" + this.props.id,
            width: "100%",
            height: "100%",
            url: url,
            alt: typeof this.props.alt === 'string' ? this.props.alt : 'untitled video',
            loop: !!this.props.options.videoLoop,
            ref: function(player) {
                return (_this.video = player);
            },
            volume: this.props.options.videoSound ? 0.8 : 0,
            playing: this.state.shouldPlay,
            onEnded: function() {
                _this.setState({
                    isPlaying: false
                });
                _this.props.actions.eventsListener(GALLERY_CONSTS.events.VIDEO_ENDED, _this.props);
            },
            onPause: function() {
                _this.setState({
                    isPlaying: false
                });
            },
            onError: function(e) {
                _this.props.actions.eventsListener(GALLERY_CONSTS.events.VIDEO_ERROR, __assign(__assign({}, _this.props), {
                    videoError: e
                }));
            },
            playbackRate: Number(this.props.options.videoSpeed) || 1,
            onStart: function() {
                if (!_this.state.playedOnce) {
                    _this.setState({
                        playedOnce: true
                    });
                }
            },
            onPlay: function() {
                _this.props.actions.eventsListener(GALLERY_CONSTS.events.VIDEO_PLAYED, _this.props);
                _this.setState({
                    isPlaying: true
                });
            },
            onReady: function() {
                _this.playVideoIfNeeded();
                _this.fixIFrameTabIndexIfNeeded();
                _this.props.actions.setItemLoaded();
                _this.setState({
                    ready: true
                });
            },
            onProgress: function() {
                if (!_this.props.shouldPlay) {
                    _this.setState({
                        shouldPlay: false
                    });
                }
            },
            controls: this.props.options.showVideoControls,
            config: {
                file: {
                    attributes: attributes,
                    forceHLS: this.shouldUseHlsPlayer(),
                    forceVideo: this.shouldForceVideoForHLS(),
                },
            },
            key: 'video-' + this.props.id
        }));
    };
    VideoItem.prototype.fixIFrameTabIndexIfNeeded = function() {
        if (this.props.isExternalVideo) {
            var videoGalleryItem = window.document &&
                window.document.getElementById("video-" + this.props.id);
            var videoIFrames = videoGalleryItem && videoGalleryItem.getElementsByTagName('iframe');
            var videoIFrame = videoIFrames && videoIFrames[0];
            if (videoIFrame) {
                if (this.props.activeIndex === this.props.idx) {
                    videoIFrame.setAttribute('tabIndex', '0');
                } else {
                    videoIFrame.setAttribute('tabIndex', '-1');
                }
            }
        }
    };
    VideoItem.prototype.getVideoContainerStyles = function() {
        var videoContainerStyle = __assign({}, this.props.imageDimensions);
        if (utils.deviceHasMemoryIssues() ||
            this.state.ready ||
            !shouldCreateVideoPlaceholder(this.props.options)) {
            // videoContainerStyle.backgroundColor = 'black';
        } else {
            videoContainerStyle.backgroundImage = "url(" + this.props.createUrl(GALLERY_CONSTS.urlSizes.RESIZED, GALLERY_CONSTS.urlTypes.HIGH_RES) + ")";
        }
        return videoContainerStyle;
    };
    //-----------------------------------------| RENDER |--------------------------------------------//
    VideoItem.prototype.render = function() {
        var _a = this.props,
            videoPlaceholder = _a.videoPlaceholder,
            hover = _a.hover;
        var baseClassName = [
            'gallery-item-content',
            'gallery-item-visible',
            'gallery-item-preloaded',
            'gallery-item-video',
            'gallery-item',
            'video-item',
        ];
        if (utils.isiPhone()) {
            baseClassName.push('ios');
        }
        if (this.state.isPlaying) {
            baseClassName.push('playing');
        }
        if (this.state.playedOnce && this.state.ready) {
            baseClassName.push('playedOnce');
        }
        if (this.props.isCurrentHover) {
            baseClassName.push('item-content-hover');
        } else {
            baseClassName.push('item-content-regular');
        }
        // eslint-disable-next-line no-unused-vars
        var video = (React.createElement("div", {
                className: baseClassName.join(' '),
                "data-hook": "video_container-video-player-element",
                key: 'video_container-' + this.props.id,
                style: this.getVideoContainerStyles()
            },
            this.createPlayerElement(),
            this.props.videoPlayButton));
        return (React.createElement("div", {
                key: 'video-and-hover-container' + this.props.idx
            },
            video,
            shouldCreateVideoPlaceholder(this.props.options) && videoPlaceholder,
            hover));
    };
    return VideoItem;
}(React.Component));
export default VideoItem;
//# sourceMappingURL=videoItem.js.map