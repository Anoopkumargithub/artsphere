import {
    ValidationFormat,
} from '@wix/ambassador-forms-v4-form/types';
import {
    EMPTY_VALUES_BY_TYPE,
    FIELD_TYPES,
    getVatIDType,
} from '@wix/form-fields';
import {
    isNumber,
    isObject,
    isString
} from '../../services/utils';
export const normalizeValues = (form, values, recursive = true) => {
    if (!form ? .fields) {
        return {};
    }
    const normalizedValues = form.fields.reduce((result, field) => {
        const fieldTarget = field.target;
        if (!fieldTarget) {
            return result;
        }
        const fieldValue = values ? .[fieldTarget];
        const fieldType = field.view ? .fieldType;
        const nestedForm = field.view ? .form;
        if (recursive && nestedForm) {
            result[fieldTarget] = normalizeValues(nestedForm, fieldValue, false);
        } else {
            result[fieldTarget] = NORMALIZED_VALUE[fieldType]({
                field,
                fieldValue,
            });
        }
        return result;
    }, {});
    return normalizedValues;
};
export const NORMALIZED_VALUE = {
    [FIELD_TYPES.TEXT_INPUT]: acceptStringValue,
    [FIELD_TYPES.CHECKBOX_GROUP]: removeInvalidOptions,
    [FIELD_TYPES.RADIO_GROUP]: acceptOnlyValidOptionByLabel,
    [FIELD_TYPES.DROPDOWN]: acceptOnlyValidOptionByLabel,
    [FIELD_TYPES.URL_INPUT]: acceptStringValue,
    [FIELD_TYPES.NUMBER_INPUT]: acceptNumberValue,
    [FIELD_TYPES.QUIZ_NUMBER]: acceptNumberValue,
    [FIELD_TYPES.QUIZ_SHORT_TEXT]: acceptStringValue,
    [FIELD_TYPES.QUIZ_LONG_TEXT]: acceptStringValue,
    [FIELD_TYPES.QUIZ_MULTI_CHOICE]: removeInvalidOptions,
    [FIELD_TYPES.QUIZ_SINGLE_CHOICE]: acceptOnlyValidOptionByLabel,
    [FIELD_TYPES.QUIZ_FILE_UPLOAD]: keepValueUnchanged,
    [FIELD_TYPES.FILE_UPLOAD]: keepValueUnchanged,
    [FIELD_TYPES.SIGNATURE]: keepValueUnchanged,
    [FIELD_TYPES.CONTACTS_EMAIL]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_PHONE]: acceptStringValue,
    [FIELD_TYPES.CHECKBOX]: acceptBooleanValue,
    [FIELD_TYPES.DATE_TIME_INPUT]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_COMPANY]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_POSITION]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_TAX_ID]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_FIRST_NAME]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_LAST_NAME]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_ADDRESS]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_BIRTHDATE]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_TEXT_INPUT]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_NUMBER_INPUT]: acceptNumberValue,
    [FIELD_TYPES.CONTACTS_DATE_INPUT]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_URL_INPUT]: acceptStringValue,
    [FIELD_TYPES.TEXT_AREA]: acceptStringValue,
    [FIELD_TYPES.CONTACTS_SUBSCRIBE]: acceptBooleanValue,
    [FIELD_TYPES.DATE_INPUT]: acceptStringValue,
    [FIELD_TYPES.TIME_INPUT]: acceptStringValue,
    [FIELD_TYPES.NESTED_FORM]: acceptObjectValue,
    [FIELD_TYPES.MULTILINE_ADDRESS]: acceptObjectValue,
    [FIELD_TYPES.MLA_COUNTRY]: acceptOnlyValidOptionByValue,
    [FIELD_TYPES.MLA_CITY]: acceptStringValue,
    [FIELD_TYPES.MLA_ADDRESS_LINE]: acceptStringValue,
    [FIELD_TYPES.MLA_ADDRESS_LINE_2]: acceptStringValue,
    [FIELD_TYPES.MLA_POSTAL_CODE]: acceptStringValue,
    [FIELD_TYPES.MLA_SUBDIVISION]: acceptOnlyValidOptionByValue,
    [FIELD_TYPES.MLA_STREET_NAME]: acceptStringValue,
    [FIELD_TYPES.MLA_STREET_NUMBER]: acceptStringValue,
    [FIELD_TYPES.MLA_APARTMENT]: acceptStringValue,
    [FIELD_TYPES.FULL_NAME]: acceptObjectValue,
    [FIELD_TYPES.FULL_NAME_FIRST_NAME]: acceptStringValue,
    [FIELD_TYPES.FULL_NAME_LAST_NAME]: acceptStringValue,
    [FIELD_TYPES.VAT_ID]: normalizeVatIDValue,
    [FIELD_TYPES.DEXT_TEXT_INPUT]: acceptStringValue,
    [FIELD_TYPES.DEXT_NUMBER_INPUT]: acceptNumberValue,
    [FIELD_TYPES.DEXT_CHECKBOX]: acceptBooleanValue,
    [FIELD_TYPES.DEXT_CHECKBOX_GROUP]: removeInvalidOptions,
    [FIELD_TYPES.ECOM_ADDITIONAL_INFO]: acceptStringValue,
    [FIELD_TYPES.ECOM_ADDRESS]: acceptObjectValue,
    [FIELD_TYPES.ECOM_PHONE]: acceptStringValue,
    [FIELD_TYPES.ECOM_FULL_NAME]: acceptObjectValue,
    [FIELD_TYPES.ECOM_COMPANY_NAME]: acceptStringValue,
    [FIELD_TYPES.ECOM_EMAIL]: acceptStringValue,
    [FIELD_TYPES.DEXT_TEXT_AREA]: acceptStringValue,
    [FIELD_TYPES.DEXT_DROPDOWN]: acceptOnlyValidOptionByLabel,
    [FIELD_TYPES.DEXT_RADIO_GROUP]: acceptOnlyValidOptionByLabel,
    [FIELD_TYPES.DEXT_URL_INPUT]: acceptStringValue,
    [FIELD_TYPES.DEXT_EMAIL]: acceptStringValue,
    [FIELD_TYPES.DEXT_PHONE]: acceptStringValue,
    [FIELD_TYPES.PRODUCT_LIST]: acceptOnlyValidProducts,
    [FIELD_TYPES.DONATION]: acceptOnlyValidProducts,
};

function keepValueUnchanged({
    fieldValue
}) {
    return fieldValue;
}

function removeInvalidOptions({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const hasAddOther = field.view ? .addOther;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (hasAddOther || isEmptyValue) {
        return fieldValue;
    }
    const options = field.view ? .options;
    if (!Array.isArray(fieldValue)) {
        return EMPTY_VALUES_BY_TYPE[fieldType];
    }
    const value = fieldValue ? .filter((arrayItem) => options.some((option) => option.value === arrayItem || option.label === arrayItem));
    return value.length ? value : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptOnlyValidOptionByLabel({
    field,
    fieldValue,
}) {
    const fieldType = field.view ? .fieldType;
    const hasAddOther = field.view ? .addOther;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (hasAddOther || isEmptyValue) {
        return fieldValue;
    }
    const options = field.view ? .options;
    const optionExists = options.some((option) => option.value === fieldValue || option.label === fieldValue);
    return optionExists ? fieldValue : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptOnlyValidProducts({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    if (!Array.isArray(fieldValue)) {
        return EMPTY_VALUES_BY_TYPE[fieldType];
    }
    const validation = field.validation;
    if (validation ? .predefined ? .format !== ValidationFormat.PAYMENT) {
        return EMPTY_VALUES_BY_TYPE[fieldType];
    }
    const validationProducts = validation.predefined.paymentOptions ? .products || [];
    if (validationProducts.length === 0) {
        return EMPTY_VALUES_BY_TYPE[fieldType];
    }
    const validProducts = fieldValue.filter((productValue) => {
        const hasAllProps = isObject(productValue) &&
            productValue.hasOwnProperty('productId') &&
            productValue.hasOwnProperty('price') &&
            productValue.hasOwnProperty('quantity');
        if (!hasAllProps) {
            return false;
        }
        const price = productValue.price;
        const isValidPrice = isString(price) ?
            Number(price).toString() === price :
            isNumber(price);
        if (!isValidPrice) {
            return false;
        }
        const isValidQuantity = isNumber(productValue.quantity);
        if (!isValidQuantity) {
            return false;
        }
        const isExisted = validationProducts.some((product) => product.id === productValue.productId);
        return isExisted;
    });
    return validProducts.length ? validProducts : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptOnlyValidOptionByValue({
    field,
    fieldValue,
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    const options = field.view ? .options;
    if (!options) {
        return EMPTY_VALUES_BY_TYPE[fieldType];
    }
    const optionExists = options.some((option) => option.value === fieldValue);
    return optionExists ? fieldValue : EMPTY_VALUES_BY_TYPE[fieldType];
}

function normalizeVatIDValue({
    field,
    fieldValue
}) {
    const vatID = fieldValue;
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    if (fieldValue &&
        isObject(fieldValue) &&
        fieldValue.hasOwnProperty('id') &&
        fieldValue.hasOwnProperty('type')) {
        const type = getVatIDType(vatID.id);
        return {
            id: vatID.id,
            type
        };
    }
    return EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptNumberValue({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    return isNumber(fieldValue) ? fieldValue : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptStringValue({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    return isString(fieldValue) ? fieldValue : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptBooleanValue({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    const isBoolean = typeof fieldValue === 'boolean';
    return isBoolean ? fieldValue : EMPTY_VALUES_BY_TYPE[fieldType];
}

function acceptObjectValue({
    field,
    fieldValue
}) {
    const fieldType = field.view ? .fieldType;
    const isEmptyValue = fieldValue === EMPTY_VALUES_BY_TYPE[fieldType];
    if (isEmptyValue) {
        return fieldValue;
    }
    return typeof fieldValue === 'object' ?
        fieldValue :
        EMPTY_VALUES_BY_TYPE[fieldType];
}
//# sourceMappingURL=normalize-values.js.map