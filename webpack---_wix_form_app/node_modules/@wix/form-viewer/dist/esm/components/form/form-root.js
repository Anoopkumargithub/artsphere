import React, {
    useEffect,
    useImperativeHandle,
    useMemo,
    useCallback,
} from 'react';
import {
    applyOverrides as applyRuleOverrides
} from '@wix/form-conditions';
import {
    formView as formViewEvent
} from '@wix/bi-logger-forms-platform-uou/v2';
import {
    AsyncValueContext,
    FieldActionsContext,
    FieldValidationContext,
    Form,
    useBi,
} from '@wix/form-fields';
import {
    deepEqual
} from 'fast-equals';
import {
    useFormValues
} from './use-form-values';
import {
    useFormView
} from './use-form-view';
import {
    useReportFieldEdit
} from './use-report-field-edit';
import {
    useSubmit
} from './use-submit';
import {
    reportErrorChanges,
    useValidation
} from './use-validation';
import {
    diff
} from '../../services/utils';
import {
    applyNestedForms
} from '../../services';
import {
    applyFormOverrides
} from '../../services/form-overrides';
import {
    DATA_HOOKS
} from '../../tpa/widget/data-hooks';
import {
    useScrollToFirstError
} from './use-scroll-to-first-error';
import {
    applyNestedFormOverrides
} from '@wix/nested-form-overrides';
import {
    useAppLoadEnded
} from '../../hooks/use-app-loaded';
import {
    getStepIndex
} from './get-step-index';
import {
    fillEmptyValues
} from './form-values';
export const FormRoot = ({
    form: unprocessedForm, // renaming form to prevent accidental use
    values: unprocessedValues, // renaming values to prevent accidental use
    stepId,
    onStepIdChange,
    onChange,
    errors,
    onValidate,
    onSubmit,
    onSubmitSuccess,
    onSubmitFailure,
    enableScrollToFirstError = true,
    forwardedRef,
    readOnly,
    style,
    overrides,
    actions,
    inProgress,
}) => {
    // `values` – we are working with the full list for all steps.
    // `errors` – working only with the errors list for the fields inside current step.
    const {
        appLoadEnded
    } = useAppLoadEnded(actions);
    const formWithOverrides = useMemo(() => applyNestedForms(applyFormOverrides(applyNestedFormOverrides(applyRuleOverrides(unprocessedForm, unprocessedValues)), overrides ? ? {})), [unprocessedForm, unprocessedValues, overrides]);
    const formId = formWithOverrides.id;
    const normalizedValues = useFormValues(formWithOverrides, unprocessedValues, onChange);
    const bi = useBi();
    const reportFieldEdit = useReportFieldEdit(formWithOverrides);
    const _onChange = (newValues) => {
        if (!deepEqual(normalizedValues, newValues)) {
            reportFieldEdit(diff(normalizedValues, newValues));
            onChange(newValues);
        }
    };
    const _onValidate = (newErrors) => {
        reportErrorChanges({
            bi,
            existingErrors: errors,
            newErrors,
            form: formWithOverrides,
        });
        onValidate(newErrors);
    };
    useEffect(() => {
        bi.report(formViewEvent({
            mode: readOnly ? 'preview' : 'live_site'
        }));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const formViews = useFormView(formWithOverrides, stepId, style ? .styleParams);
    const currentView = formViews[0];
    const {
        validateFields,
        validateStep,
        handleFieldValidation
    } = useValidation({
        form: formWithOverrides,
        errors,
        setErrors: _onValidate,
    });
    const handleStepChange = (step) => {
        const newStepId = formWithOverrides.steps ? .[step] ? .id;
        if (newStepId) {
            onStepIdChange ? .(newStepId);
        }
    };
    const {
        scrollToFirstError,
        handleScrollToFirstError
    } = useScrollToFirstError({
        form: formWithOverrides,
        options: {
            enableScrollToFirstError
        },
        handleStepChange,
        currentStepId: stepId,
    });
    const resetFormValues = useCallback(() => {
        onChange(fillEmptyValues(formWithOverrides, {}));
    }, [formWithOverrides, onChange]);
    const validateAndScrollToError = useCallback(async (values) => {
        const validationErrors = await validateFields(values);
        if (validationErrors && validationErrors.length) {
            handleScrollToFirstError(validationErrors);
        }
        return validationErrors;
    }, [validateFields, handleScrollToFirstError]);
    const submitAction = useCallback(async (values) => {
        const response = await actions ? .submitForm ? .(formId, values);
        return response ? .submission;
    }, [actions, formId]);
    const {
        asyncValues,
        submitForm
    } = useSubmit({
        submitAction,
        onChange,
        onSubmit,
        onSubmitSuccess,
        onSubmitFailure,
        resetFormValues,
        validateAndScrollToError,
        values: normalizedValues,
    });
    useImperativeHandle(forwardedRef, () => ({
        submit: submitForm,
        validate: async () => {
            const validationErrors = await validateFields(normalizedValues);
            if (validationErrors && validationErrors.length > 0) {
                if (enableScrollToFirstError) {
                    scrollToFirstError();
                }
                return false;
            }
            return true;
        },
        validateStep: (step) => validateStep(step, normalizedValues),
    }), [
        submitForm,
        validateStep,
        validateFields,
        normalizedValues,
        enableScrollToFirstError,
        scrollToFirstError,
    ]);
    const currentStep = getStepIndex(stepId, formWithOverrides.steps);
    const setNextStep = () => handleStepChange(currentStep + 1);
    const setPreviousStep = () => handleStepChange(currentStep - 1);
    const fieldActions = useMemo(() => actions ?
        {
            actions: { ...actions,
                submitForm,
                setNextStep,
                setPreviousStep
            },
            formId,
            inProgress,
        } :
        {
            actions: {
                submitForm,
                setNextStep,
                setPreviousStep
            }
        }, [actions, formId, inProgress, submitForm]);
    appLoadEnded();
    if (!formViews ? .length || !currentView) {
        return null;
    }
    return (React.createElement(FieldValidationContext.Provider, {
            value: {
                validateFields: handleFieldValidation,
            }
        },
        React.createElement(FieldActionsContext.Provider, {
                value: fieldActions
            },
            React.createElement(AsyncValueContext.Provider, {
                    value: asyncValues
                },
                React.createElement("div", {
                        "data-hook": DATA_HOOKS.FORM_ROOT
                    },
                    React.createElement(Form, {
                        form: currentView,
                        values: normalizedValues,
                        onChange: _onChange,
                        errors: errors
                    }))))));
};
//# sourceMappingURL=form-root.js.map