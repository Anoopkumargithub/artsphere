import {
    validate
} from './validation';
import {
    runAdditionalValidation
} from './additional-field-validation';
export const getFieldErrors = async (fieldToValidate, form, errors) => {
    const formValues = setValue({}, fieldToValidate.path, fieldToValidate.value);
    const result = await validate(form, formValues);
    const _errors = result ? .errors || [];
    const additionalErrors = runAdditionalValidation({
        form,
        values: formValues,
    });
    const allErrors = mergeErrors({
        errors: _errors,
        additionalErrors
    });
    const filteredErrors = errors.filter((error) => error.errorPath !== fieldToValidate.path);
    const fieldErrors = allErrors.filter((error) => error.errorPath === fieldToValidate.path);
    return [...filteredErrors, ...fieldErrors];
};

function setValue(object, path, value) {
    const delimiter = '/';
    const decomposedPath = path.split(delimiter);
    const base = decomposedPath[0];
    if (base === undefined) {
        return object;
    }
    if (!object.hasOwnProperty(base)) {
        object[base] = {};
    }
    value =
        decomposedPath.length <= 1 ?
        value :
        setValue(object[base], decomposedPath.slice(1).join(delimiter), value);
    return {
        ...object,
        [base]: value,
    };
}
export const mergeErrors = ({
    errors,
    additionalErrors,
}) => {
    const errorsToAdd = [];
    if (additionalErrors) {
        Object.keys(additionalErrors).forEach((fieldTarget) => {
            const errorExists = errors.find((error) => error.errorPath === fieldTarget);
            if (!errorExists) {
                errorsToAdd.push(additionalErrors[fieldTarget]);
            }
        });
    }
    return [...errors, ...errorsToAdd];
};
//# sourceMappingURL=get-field-errors.js.map