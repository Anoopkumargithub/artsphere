"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Rule = void 0;
var condition_1 = require("./condition");
var default_engine_1 = require("./default-engine");
/**
 * Rule.
 */
var Rule = /** @class */ (function() {
    function Rule(json, engine) {
        /**
         * Rule type.
         */
        this.type = 'and';
        /**
         * Rule items.
         */
        this.items = [];
        /**
         * Engine instance.
         */
        this.engine = default_engine_1.defaultEngine;
        if (engine) {
            this.engine = engine;
        }
        if (json) {
            this.init(json);
        }
    }
    /**
     * Add a condition with an equals operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.equals = function(fact, value) {
        return this.add(fact, 'equals', value);
    };
    /**
     * Add a condition with an notEquals operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.notEquals = function(fact, value) {
        return this.add(fact, 'notEquals', value);
    };
    /**
     * Add a condition with an in operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.in = function(fact, value) {
        return this.add(fact, 'in', value);
    };
    /**
     * Add a condition with an notIn operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.notIn = function(fact, value) {
        return this.add(fact, 'notIn', value);
    };
    /**
     * Add a condition with an contains operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.contains = function(fact, value) {
        return this.add(fact, 'contains', value);
    };
    /**
     * Add a condition with an notContains operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.notContains = function(fact, value) {
        return this.add(fact, 'notContains', value);
    };
    /**
     * Add a condition with an lessThan operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.lessThan = function(fact, value) {
        return this.add(fact, 'lessThan', value);
    };
    /**
     * Add a condition with an lessThanOrEquals operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.lessThanOrEquals = function(fact, value) {
        return this.add(fact, 'lessThanOrEquals', value);
    };
    /**
     * Add a condition with an greaterThan operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.greaterThan = function(fact, value) {
        return this.add(fact, 'greaterThan', value);
    };
    /**
     * Add a condition with an greaterThanOrEquals operator.
     *
     * @param fact Property name or dot notation path.
     * @param value Value to compare.
     */
    Rule.prototype.greaterThanOrEquals = function(fact, value) {
        return this.add(fact, 'greaterThanOrEquals', value);
    };
    /**
     * Add a condition.
     *
     * @param fact Property name or dot notation path.
     * @param operator Name of operator to use.
     * @param value Value to compare.
     */
    Rule.prototype.add = function(fact, operator, value) {
        this.items.push(new condition_1.Condition({
            fact: fact,
            operator: operator,
            value: value
        }, this.engine));
        return this;
    };
    /**
     * Add a nested AND rule.
     *
     * @param fn Callback function.
     */
    Rule.prototype.and = function(fn) {
        var rule = new Rule(null, this.engine);
        rule.type = 'and';
        fn.call(null, rule);
        this.items.push(rule);
        return this;
    };
    /**
     * Add a nested OR rule.
     *
     * @param fn Callback function.
     */
    Rule.prototype.or = function(fn) {
        var rule = new Rule(null, this.engine);
        rule.type = 'or';
        fn.call(null, rule);
        this.items.push(rule);
        return this;
    };
    /**
     * Evaluate a rule's conditions against the provided data.
     *
     * @param data Data object to use.
     */
    Rule.prototype.evaluate = function(data) {
        for (var _i = 0, _a = this.items; _i < _a.length; _i++) {
            var item = _a[_i];
            var result = item.evaluate(data);
            if (this.type === 'and' && !result) {
                return false;
            } else if (this.type === 'or' && result) {
                return true;
            }
        }
        if (this.type === 'and') {
            return true;
        } else {
            return false;
        }
    };
    /**
     * To json.
     */
    Rule.prototype.toJSON = function() {
        var _a;
        return _a = {},
            _a[this.type] = this.items,
            _a;
    };
    /**
     * Init rule from json object.
     *
     * @param json Json object.
     */
    Rule.prototype.init = function(json) {
        var _this = this;
        var hasOr = Object.prototype.hasOwnProperty.call(json, 'or');
        var hasAnd = Object.prototype.hasOwnProperty.call(json, 'and');
        if (hasOr && hasAnd) {
            throw new Error('Rule: can only have on property ("and" / "or")');
        }
        var items = json.or || json.and || [];
        this.type = hasOr ? 'or' : 'and';
        this.items = items.map(function(item) {
            if (_this.isRule(item)) {
                return new Rule(item, _this.engine);
            } else {
                return new condition_1.Condition(item, _this.engine);
            }
        });
    };
    /**
     * Identifies if a json object is a rule or a condition.
     *
     * @param json Object to check.
     */
    Rule.prototype.isRule = function(json) {
        return (Object.prototype.hasOwnProperty.call(json, 'and') ||
            Object.prototype.hasOwnProperty.call(json, 'or'));
    };
    return Rule;
}());
exports.Rule = Rule;
//# sourceMappingURL=rule.js.map