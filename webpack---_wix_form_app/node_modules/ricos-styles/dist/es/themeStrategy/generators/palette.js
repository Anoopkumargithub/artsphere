import {
    t as toHexFormat,
    a as adaptForeground,
    b as toRgbTuple,
    c as canTransformToHex,
    e as toCssRgb
} from '../../themeUtils-3da3397c.js';
import {
    isRicosPaletteRgb
} from './identifiers.js';
import presets from '../palettes/presets.js';
import {
    assertWixPalette,
    getColorValue,
    COLORS,
    isRicosPalette
} from '../palettes/wixPaletteUtils.js';
import 'lodash';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
const createCssVars = (colors, config) => {
    const {
        contentBgColor = false, focusActionColor, settingsActionColor
    } = config || {};
    const isPaletteRgb = isRicosPaletteRgb(colors);
    const {
        textColor,
        bgColor: backgroundColor,
        actionColor,
        fallbackColor = isPaletteRgb ? "0, 0, 0" : "#000000",
        disabledColor,
        textColorLow
    } = colors;
    const parseColors = (obj) => Object.keys(obj).reduce((acc, key) => {
        const value = obj[key];
        if (value !== void 0) {
            const transformedValue = canTransformToHex(value) && isPaletteRgb ? toRgbTuple(toHexFormat(value)) : void 0;
            const colorValue = transformedValue !== void 0 ? transformedValue : value;
            acc[key] = isPaletteRgb ? toCssRgb(colorValue) : colorValue;
            acc[`${key}Tuple`] = isPaletteRgb ? colorValue : toRgbTuple(colorValue);
        }
        return acc;
    }, {});
    const parsedValues = parseColors({
        textColor,
        actionColor,
        backgroundColor,
        fallbackColor,
        disabledColor,
        textColorLow,
        settingsActionColor,
        focusActionColor
    });
    const bgColorContainer = !contentBgColor || backgroundColor === void 0 ? void 0 : isPaletteRgb ? toCssRgb(backgroundColor) : backgroundColor;
    const actionColorFallback = isPaletteRgb ? `rgb(${fallbackColor})` : adaptForeground(actionColor, fallbackColor);
    const actionColorFallbackTuple = isPaletteRgb ? fallbackColor : toRgbTuple(adaptForeground(actionColor, fallbackColor));
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, parsedValues), actionColorFallback && {
        actionColorFallback
    }), actionColorFallbackTuple && {
        actionColorFallbackTuple
    }), bgColorContainer && {
        bgColorContainer
    });
};
const extractColors = (palette) => {
    if (typeof palette === "string") {
        if (palette in presets) {
            return presets[palette];
        } else {
            throw Error(`Palette ${palette} is unknown. Supported themes: ${presets}`);
        }
    } else if (Array.isArray(palette)) {
        assertWixPalette(palette);
        return {
            actionColor: getColorValue(palette, COLORS.ACTION_COLOR),
            bgColor: getColorValue(palette, COLORS.BG_COLOR),
            textColor: getColorValue(palette, COLORS.TEXT_COLOR),
            disabledColor: getColorValue(palette, COLORS.DISABLED_COLOR),
            textColorLow: getColorValue(palette, COLORS.TEXT_COLOR_LOW)
        };
    } else if (palette && (isRicosPalette(palette) || isRicosPaletteRgb(palette))) {
        return palette;
    }
    throw Error("Unrecognized Palette object. Please refer to Ricos Theme Documentation");
};

function createPalette(palette, config) {
    if (!palette) {
        return {
            paletteVarsObject: {}
        };
    }
    const isPalleteRgb = isRicosPaletteRgb(palette);
    const colors = extractColors(palette);
    Object.entries(colors).forEach(
        ([colorName, value]) => colors[colorName] = value && typeof value === "string" && !isPalleteRgb ? toHexFormat(value) : value
    );
    const paletteVarsObject = createCssVars(colors, config);
    return {
        paletteVarsObject,
        colors
    };
}

export {
    createPalette as
    default
};
//# sourceMappingURL=palette.js.map