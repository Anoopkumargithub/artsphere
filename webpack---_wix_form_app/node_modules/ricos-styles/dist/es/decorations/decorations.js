import {
    Decoration_Type
} from 'ricos-schema';
import {
    BoldDecoration
} from './bold-decoration.js';
import {
    ColorDecoration
} from './color-decoration.js';
import {
    EmptyDecoration
} from './empty-decoration.js';
import {
    FontSizeDecoration
} from './font-size-decoration.js';
import {
    ItalicDecoration
} from './italic-decoration.js';
import {
    a as firstRight
} from '../utils-4912d41d.js';
import 'lodash';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
                target[prop] = source[prop];
        }
    return target;
};
const _Decorations = class {
    constructor(textDecorations) {
        this.decorations = textDecorations;
    }
    static of (decorations) {
        const textDecorations = (decorations || []).map(_Decorations.toTextDecoration);
        return new _Decorations(textDecorations);
    }
    static fromCustomStyle(customStyle) {
        const _a = customStyle,
            {
                color,
                backgroundColor
            } = _a,
            rest = __objRest(_a, ["color", "backgroundColor"]);
        const colorStyle = {
            color: color != null ? color : "",
            backgroundColor: backgroundColor != null ? backgroundColor : ""
        };
        const styles = Object.entries(rest).map(([k, v]) => ({
            [k]: v
        })).concat([colorStyle]);
        const textDecorations = styles.map(_Decorations.styleToDecoration);
        return new _Decorations(textDecorations);
    }
    static styleToDecoration(style) {
        return firstRight(style, _Decorations.empty, [
            [(s) => !!s.fontWeight, (s) => BoldDecoration.fromCustomStyle(s)],
            [(s) => !!s.fontSize, (s) => FontSizeDecoration.fromCustomStyle(s)],
            [(s) => !!s.fontStyle, (s) => ItalicDecoration.fromCustomStyle(s)],
            [(s) => !!s.color || !!s.backgroundColor, (s) => ColorDecoration.fromCustomStyle(s)]
        ]);
    }
    static toTextDecoration(decoration) {
        return firstRight(decoration, _Decorations.empty, [
            [(d) => d.type === Decoration_Type.BOLD, (d) => BoldDecoration.of(d)],
            [(d) => d.type === Decoration_Type.ITALIC, (d) => ItalicDecoration.of(d)],
            [(d) => d.type === Decoration_Type.FONT_SIZE, (d) => FontSizeDecoration.of(d)],
            [(d) => d.type === Decoration_Type.COLOR, (d) => ColorDecoration.of(d)]
        ]);
    }
    toDecorationArray() {
        return this.decorations.filter((d) => d.type !== Decoration_Type.UNRECOGNIZED).map((d) => d.getDecoration());
    }
    byType(type) {
        return this.decorations.find((d) => d.type === type) || _Decorations.empty;
    }
    toCustomStyle() {
        return this.decorations.reduce(
            (style, decoration) => __spreadValues(__spreadValues({}, style), decoration.toCustomStyle()), {}
        );
    }
    overrideWith(decorations) {
        const textDecorations = decorations.map(_Decorations.toTextDecoration);
        const overridenDecorations = textDecorations.map(
            (decoration) => this.byType(decoration.type).overrideWith(decoration)
        );
        const types = overridenDecorations.map((decoration) => decoration.type);
        const mergedDecorations = this.decorations.filter((decoration) => !types.includes(decoration.type)).concat(overridenDecorations);
        return new _Decorations(mergedDecorations);
    }
};
let Decorations = _Decorations;
Decorations.empty = new EmptyDecoration();

export {
    Decorations
};
//# sourceMappingURL=decorations.js.map