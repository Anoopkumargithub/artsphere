import {
    Decoration_Type,
    FontSizeData_fontType
} from 'ricos-schema';
import {
    EmptyDecoration
} from './empty-decoration.js';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
class FontSizeDecoration {
    constructor(customStyle) {
        this.type = Decoration_Type.FONT_SIZE;
        this.customStyle = customStyle;
    }
    static of (decoration) {
        var _a, _b, _c;
        if (decoration.type !== Decoration_Type.FONT_SIZE) {
            throw new TypeError(`invalid decoration initializer ${decoration}`);
        }
        const value = (_a = decoration.fontSizeData) == null ? void 0 : _a.value;
        const unit = (_c = (_b = decoration.fontSizeData) == null ? void 0 : _b.unit) == null ? void 0 : _c.toLocaleLowerCase();
        const customStyle = value ? {
            fontSize: `${value}${unit}`
        } : {};
        return new FontSizeDecoration(customStyle);
    }
    getDecoration() {
        return {
            type: this.type,
            fontSizeData: {
                value: parseInt(this.customStyle.fontSize),
                unit: FontSizeData_fontType.PX
            }
        };
    }
    static fromCustomStyle(customStyle) {
        return new FontSizeDecoration(customStyle);
    }
    fromCustomStyle(customStyle) {
        return FontSizeDecoration.fromCustomStyle(customStyle);
    }
    toCustomStyle() {
        return this.customStyle;
    }
    overrideWith(decoration) {
        if (!(decoration instanceof FontSizeDecoration || decoration instanceof EmptyDecoration)) {
            throw new TypeError(`invalid merge decoration ${decoration}`);
        }
        const customStyle = __spreadValues(__spreadValues({}, this.customStyle), decoration.toCustomStyle());
        return new FontSizeDecoration(customStyle);
    }
}

export {
    FontSizeDecoration
};
//# sourceMappingURL=font-size-decoration.js.map