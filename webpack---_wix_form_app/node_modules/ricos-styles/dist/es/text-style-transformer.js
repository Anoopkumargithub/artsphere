import {
    p as pipe,
    m as map,
    f as flow
} from './utils-4912d41d.js';
import {
    fromEntries
} from 'ricos-content/libs/utils';
import {
    RicosNodeStyle
} from './document-style/node-style.js';
import {
    RicosTextStyle
} from './document-style/text-style.js';
import CustomStyles from './textual-theme/custom-styles.js';
import {
    Decorations
} from './decorations/decorations.js';
import 'lodash';
import './themeStrategy/generators/palette.js';
import './themeUtils-3da3397c.js';
import './themeStrategy/generators/identifiers.js';
import './themeStrategy/palettes/presets.js';
import './themeStrategy/palettes/wixPaletteUtils.js';
import './textual-theme/custom-style.js';
import './textual-theme/empty-custom-style.js';
import 'ricos-schema';
import './decorations/bold-decoration.js';
import './decorations/empty-decoration.js';
import './decorations/color-decoration.js';
import './decorations/font-size-decoration.js';
import './decorations/italic-decoration.js';

// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)
 * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)
 *
 * @category instances
 * @since 2.10.0
 */
var Eq = {
    equals: function(first, second) {
        return first === second;
    }
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)
 * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)
 * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)
 *
 * @category instances
 * @since 2.10.0
 */
var Ord = {
    equals: Eq.equals,
    compare: function(first, second) {
        return (first < second ? -1 : first > second ? 1 : 0);
    }
};

var __assign = (undefined && undefined.__assign) || function() {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var keys_ = function(O) {
    return function(r) {
        return Object.keys(r).sort(O.compare);
    };
};

function collect(O) {
    if (typeof O === 'function') {
        return collect(Ord)(O);
    }
    var keysO = keys_(O);
    return function(f) {
        return function(r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
                var key = _a[_i];
                out.push(f(key, r[key]));
            }
            return out;
        };
    };
}
/**
 * Get a sorted `Array` of the key/value pairs contained in a `Record`.
 * Sorted alphabetically by key.
 *
 * @example
 * import { toArray } from 'fp-ts/Record'
 *
 * const x = { c: 3, a: "foo", b: false };
 * assert.deepStrictEqual(toArray(x), [
 *   ["a", "foo"],
 *   ["b", false],
 *   ["c", 3],
 * ]);
 *
 * @category conversions
 * @since 2.0.0
 */
var toArray = /*#__PURE__*/ collect(Ord)(function(k, a) {
    return [
        k,
        a
    ];
});

// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @since 2.5.0
 */
function fst$1(ea) {
    return ea[0];
}
/**
 * @since 2.5.0
 */
function snd$1(ea) {
    return ea[1];
}

// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 */
var fst = fst$1;
/**
 * @since 2.0.0
 */
var snd = snd$1;
/**
 * @since 2.0.0
 */
var swap = function(ea) {
    return [snd(ea), fst(ea)];
};
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category mapping
 * @since 2.0.0
 */
var bimap = function(f, g) {
    return function(fa) {
        return [g(fst(fa)), f(snd(fa))];
    };
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
const documentToThemeKeyMap = {
    headerOne: "h1",
    headerTwo: "h2",
    headerThree: "h3",
    headerFour: "h4",
    headerFive: "h5",
    headerSix: "h6",
    paragraph: "p",
    blockquote: "quote",
    codeBlock: "codeBlock"
};
const themeToDocumentKeyMap = pipe(
    documentToThemeKeyMap,
    Object.entries,
    map(swap),
    fromEntries
);
const toCustomStyle = (node) => __spreadValues(__spreadValues(__spreadValues({}, Decorations.of(node == null ? void 0 : node.decorations).toCustomStyle()), RicosNodeStyle.of(node == null ? void 0 : node.nodeStyle).toCustomStyle()), RicosTextStyle.of({
    lineHeight: node == null ? void 0 : node.lineHeight
}).toCustomStyle());
const toCustomStyleKey = (nodeType) => documentToThemeKeyMap[nodeType];
const toTuples = (documentStyle) => toArray(documentStyle);
const fromTuples = (tuple) => fromEntries(tuple);
const toRicosCustomStyles = flow(
    toTuples,
    map(bimap(toCustomStyle, toCustomStyleKey)),
    fromTuples
);
const toTextNodeStyle = (customStyle) => ({
    decorations: Decorations.fromCustomStyle(customStyle).toDecorationArray(),
    nodeStyle: RicosNodeStyle.fromCustomStyle(customStyle).getNodeStyle(),
    lineHeight: RicosTextStyle.fromCustomStyle(customStyle).getTextStyle().lineHeight
});
const toTextNodeType = (customStyleKey) => themeToDocumentKeyMap[customStyleKey];
const toDocumentStyle = flow(
    Object.entries,
    map(bimap(toTextNodeStyle, toTextNodeType)),
    fromEntries,
    JSON.stringify,
    JSON.parse
);
class TextStyleTransformer {
    constructor(theme) {
        this.theme = theme;
    }
    static fromTheme(theme) {
        return new TextStyleTransformer(theme || {});
    }
    static fromDocumentStyle(documentStyle) {
        const customStyles = toRicosCustomStyles(documentStyle);
        return new TextStyleTransformer({
            customStyles
        });
    }
    toTheme() {
        return this.theme;
    }
    toDocumentStyle() {
        return toDocumentStyle(CustomStyles.fromTheme(this.theme).toCustomStyles());
    }
}

export {
    TextStyleTransformer
};
//# sourceMappingURL=text-style-transformer.js.map