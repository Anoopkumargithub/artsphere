import {
    countBy,
    camelCase
} from 'lodash';
import {
    DIVIDER_TYPE,
    IMAGE_TYPE,
    GALLERY_TYPE,
    GIPHY_TYPE,
    HTML_TYPE,
    VIDEO_TYPE,
    FILE_UPLOAD_TYPE,
    POLL_TYPE,
    COLLAPSIBLE_LIST_TYPE,
    TABLE_TYPE,
    LINK_PREVIEW_TYPE,
    APP_EMBED_TYPE,
    MAP_TYPE,
    AUDIO_TYPE,
    LINK_BUTTON_TYPE,
    CODE_BLOCK_TYPE,
    BLOCKQUOTE,
    MENTION_TYPE,
    LINK_TYPE,
    ANCHOR_TYPE,
    EMOJI_TYPE
} from 'ricos-content';
import {
    extract
} from 'ricos-content/libs/extract';
import {
    Node_Type,
    Decoration_Type
} from 'ricos-schema';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const countByType = (obj) => countBy(obj, (x) => x.type);
const TO_PLUGIN_TYPE = {
    [Node_Type.DIVIDER]: DIVIDER_TYPE,
    [Node_Type.IMAGE]: IMAGE_TYPE,
    [Node_Type.GALLERY]: GALLERY_TYPE,
    [Node_Type.GIF]: GIPHY_TYPE,
    [Node_Type.HTML]: HTML_TYPE,
    [Node_Type.VIDEO]: VIDEO_TYPE,
    [Node_Type.FILE]: FILE_UPLOAD_TYPE,
    [Node_Type.POLL]: POLL_TYPE,
    [Node_Type.COLLAPSIBLE_LIST]: COLLAPSIBLE_LIST_TYPE,
    [Node_Type.TABLE]: TABLE_TYPE,
    [Node_Type.EMBED]: LINK_PREVIEW_TYPE,
    [Node_Type.LINK_PREVIEW]: LINK_PREVIEW_TYPE,
    [Node_Type.APP_EMBED]: APP_EMBED_TYPE,
    [Node_Type.MAP]: MAP_TYPE,
    [Node_Type.AUDIO]: AUDIO_TYPE,
    [Node_Type.BUTTON]: LINK_BUTTON_TYPE,
    [Node_Type.CODE_BLOCK]: CODE_BLOCK_TYPE,
    [Node_Type.BLOCKQUOTE]: BLOCKQUOTE
};
const headingLevelToTag = {
    1: "header-one",
    2: "header-two",
    3: "header-three",
    4: "header-four",
    5: "header-five",
    6: "header-six"
};
const DECORATION_TO_NODE_TYPE = {
    [Decoration_Type.MENTION]: MENTION_TYPE,
    [Decoration_Type.LINK]: LINK_TYPE,
    [Decoration_Type.ANCHOR]: ANCHOR_TYPE
};
const emojiRegex = /\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]/g;

function getContentSummary(content) {
    const {
        nodes
    } = content;
    const plugins = extract(nodes).filter(
        (node) => ![
            Node_Type.PARAGRAPH,
            Node_Type.TEXT,
            Node_Type.UNRECOGNIZED,
            Node_Type.COLLAPSIBLE_ITEM,
            Node_Type.COLLAPSIBLE_ITEM_BODY,
            Node_Type.COLLAPSIBLE_ITEM_TITLE,
            Node_Type.TABLE_CELL,
            Node_Type.TABLE_ROW
        ].includes(node.type)
    ).map((node) => {
        const {
            type
        } = node;
        const data = node[`${camelCase(type)}Data`];
        const details = {};
        const plugin_type = TO_PLUGIN_TYPE[type] || type === Node_Type.HEADING && headingLevelToTag[data.level];
        if (plugin_type) {
            details.type = plugin_type;
            if (data) {
                details.data = data;
            }
        }
        return details;
    }).filter((node) => !!node.type).get();
    const decorations = extract(nodes).filter((node) => {
        var _a, _b;
        return !!((_b = (_a = node.textData) == null ? void 0 : _a.decorations) == null ? void 0 : _b.some(
            (decoration) => [Decoration_Type.ANCHOR, Decoration_Type.LINK, Decoration_Type.MENTION].includes(
                decoration.type
            )
        ));
    }).map((node) => {
        var _a;
        const data = (_a = node.textData) == null ? void 0 : _a.decorations.find(
            (decoration) => DECORATION_TO_NODE_TYPE[decoration.type]
        );
        const details = {};
        const plugin_type = (data == null ? void 0 : data.type) && DECORATION_TO_NODE_TYPE[data.type];
        if (plugin_type) {
            details.type = plugin_type;
            if (data) {
                details.data = data[`${camelCase(data.type.toLowerCase())}Data`];
            }
        }
        return details;
    }).filter((node) => !!node.type).get();
    const emoji = extract(nodes).map(({
        textData
    }) => (textData == null ? void 0 : textData.text) || "").get().reduce((acc, text) => {
        return acc + (text.match(emojiRegex) || []).length;
    }, 0);
    return {
        pluginsCount: __spreadProps(__spreadValues(__spreadValues({}, countByType(plugins)), countByType(decorations)), {
            [EMOJI_TYPE]: emoji
        }),
        pluginsDetails: [...plugins, ...decorations]
    };
}

export {
    countByType,
    getContentSummary
};
//# sourceMappingURL=ricosContentAnalytics.js.map