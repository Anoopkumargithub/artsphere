import {
    h as has$1,
    s as some,
    n as none
} from './ReadonlyNonEmptyArray-3599e877.js';
import './string-04247af1.js';

/**
 * Test whether a `ReadonlyRecord` is empty.
 *
 * @example
 * import { isEmpty } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(isEmpty({}), true);
 * assert.deepStrictEqual(isEmpty({ a: 3 }), false);
 * @since 2.5.0
 */
var isEmpty = function(r) {
    for (var k in r) {
        if (has$1.call(r, k)) {
            return false;
        }
    }
    return true;
};
/**
 * Insert or replace a key/value pair in a `ReadonlyRecord`.
 *
 * @example
 * import { upsertAt } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.10.0
 */
var upsertAt = function(k, a) {
    return function(r) {
        if (has$1.call(r, k) && r[k] === a) {
            return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
    };
};
/**
 * Test whether or not a key exists in a `ReadonlyRecord`.
 *
 * Note. This function is not pipeable because is a `Refinement`.
 *
 * @example
 * import { has } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(has("a", { a: 1, b: 2 }), true);
 * assert.deepStrictEqual(has("c", { a: 1, b: 2 }), false);
 *
 * @since 2.10.0
 */
var has = function(k, r) {
    return has$1.call(r, k);
};

function deleteAt(k) {
    return function(r) {
        if (!has$1.call(r, k)) {
            return r;
        }
        var out = Object.assign({}, r);
        delete out[k];
        return out;
    };
}

function isSubrecord(E) {
    return function(me, that) {
        if (that === undefined) {
            var isSubrecordE_1 = isSubrecord(E);
            return function(that) {
                return isSubrecordE_1(that, me);
            };
        }
        for (var k in me) {
            if (!has$1.call(that, k) || !E.equals(me[k], that[k])) {
                return false;
            }
        }
        return true;
    };
}

function lookup(k, r) {
    if (r === undefined) {
        return function(r) {
            return lookup(k, r);
        };
    }
    return has$1.call(r, k) ? some(r[k]) : none;
}
/**
 * @since 2.5.0
 */
var empty = {};

function getMonoid(S) {
    return {
        concat: function(first, second) {
            if (isEmpty(first)) {
                return second;
            }
            if (isEmpty(second)) {
                return first;
            }
            var r = Object.assign({}, first);
            for (var k in second) {
                if (has$1.call(second, k)) {
                    r[k] = has$1.call(first, k) ? S.concat(first[k], second[k]) : second[k];
                }
            }
            return r;
        },
        empty: empty
    };
}
/**
 * Use [`upsertAt`](#upsertat) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var insertAt = upsertAt;

export {
    insertAt as a, deleteAt as d, getMonoid as g, has as h, isSubrecord as i, lookup as l
};
//# sourceMappingURL=ReadonlyRecord-da7aaead.js.map