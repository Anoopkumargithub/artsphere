import {
    p as pipe$1,
    g as dual,
    i as identity,
    u as unsafeCoerce,
    f as flow,
    j as constant
} from './ReadonlyNonEmptyArray-3599e877.js';
import {
    z as getMonoid,
    A as traverse$2,
    B as some$1,
    j as chain,
    h as fold$1,
    C as getOrElse,
    D as unsafeUpdateAt$1,
    E as findIndex,
    F as findFirst$1,
    G as lookup,
    H as isNone,
    w as fromNullable$1,
    b as fromPredicate$1,
    r as right$1,
    I as fromEither,
    l as left$1,
    J as isLeft,
    K as none,
    i as map$2,
    L as option,
    p as of$1,
    M as monoidAny,
    N as monoidAll,
    O as getFirstMonoid
} from './Option-87dfe66c.js';
import {
    l as lookup$1,
    a as insertAt,
    d as deleteAt
} from './ReadonlyRecord-da7aaead.js';

/**
 * @category constructors
 * @since 2.0.0
 */
function make$1(value, forest) {
    if (forest === void 0) {
        forest = [];
    }
    return {
        value: value,
        forest: forest
    };
}
/**
 * Build a (possibly infinite) tree from a seed value in breadth-first order.
 *
 * @category constructors
 * @since 2.0.0
 */
function unfoldTree(b, f) {
    var _a = f(b),
        a = _a[0],
        bs = _a[1];
    return {
        value: a,
        forest: unfoldForest(bs, f)
    };
}
/**
 * Build a (possibly infinite) forest from a list of seed values in breadth-first order.
 *
 * @category constructors
 * @since 2.0.0
 */
function unfoldForest(bs, f) {
    return bs.map(function(b) {
        return unfoldTree(b, f);
    });
}
/**
 * Fold a tree into a "summary" value in depth-first order.
 *
 * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.
 *
 * This is also known as the catamorphism on trees.
 *
 * @example
 * import { fold, make } from 'fp-ts/Tree'
 * import { concatAll } from 'fp-ts/Monoid'
 * import { MonoidSum } from 'fp-ts/number'
 *
 * const t = make(1, [make(2), make(3)])
 *
 * const sum = concatAll(MonoidSum)
 *
 * // Sum the values in a tree:
 * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)
 *
 * // Find the maximum value in the tree:
 * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)
 *
 * // Count the number of leaves in the tree:
 * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)
 *
 * @category folding
 * @since 2.6.0
 */
function fold(f) {
    var go = function(tree) {
        return f(tree.value, tree.forest.map(go));
    };
    return go;
}
/* istanbul ignore next */
var _map$1 = function(fa, f) {
    return pipe$1(fa, map$1(f));
};
var _ap = function(fab, fa) {
    return flatMap(fab, function(f) {
        return pipe$1(fa, map$1(f));
    });
};
/* istanbul ignore next */
var _reduce = function(fa, b, f) {
    return pipe$1(fa, reduce(b, f));
};
/* istanbul ignore next */
var _foldMap = function(M) {
    var foldMapM = foldMap(M);
    return function(fa, f) {
        return pipe$1(fa, foldMapM(f));
    };
};
/* istanbul ignore next */
var _reduceRight = function(fa, b, f) {
    return pipe$1(fa, reduceRight(b, f));
};
/* istanbul ignore next */
var _extend = function(wa, f) {
    return pipe$1(wa, extend(f));
};
/* istanbul ignore next */
var _traverse = function(F) {
    var traverseF = traverse$1(F);
    return function(ta, f) {
        return pipe$1(ta, traverseF(f));
    };
};
/**
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ dual(2, function(ma, f) {
    var _a = f(ma.value),
        value = _a.value,
        forest = _a.forest;
    var concat = getMonoid().concat;
    return {
        value: value,
        forest: concat(forest, ma.forest.map(flatMap(f)))
    };
});
/**
 * @since 2.0.0
 */
var extend = function(f) {
    return function(wa) {
        return ({
            value: f(wa),
            forest: wa.forest.map(extend(f))
        });
    };
};
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.0.0
 */
var map$1 = function(f) {
    return function(fa) {
        return ({
            value: f(fa.value),
            forest: fa.forest.map(map$1(f))
        });
    };
};
/**
 * @category folding
 * @since 2.0.0
 */
var reduce = function(b, f) {
    return function(fa) {
        var r = f(b, fa.value);
        var len = fa.forest.length;
        for (var i = 0; i < len; i++) {
            r = pipe$1(fa.forest[i], reduce(r, f));
        }
        return r;
    };
};
/**
 * @category folding
 * @since 2.0.0
 */
var foldMap = function(M) {
    return function(f) {
        return reduce(M.empty, function(acc, a) {
            return M.concat(acc, f(a));
        });
    };
};
/**
 * @category folding
 * @since 2.0.0
 */
var reduceRight = function(b, f) {
    return function(fa) {
        var r = b;
        var len = fa.forest.length;
        for (var i = len - 1; i >= 0; i--) {
            r = pipe$1(fa.forest[i], reduceRight(r, f));
        }
        return f(fa.value, r);
    };
};
/**
 * @category Extract
 * @since 2.6.2
 */
var extract = function(wa) {
    return wa.value;
};
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse$1 = function(F) {
    var traverseF = traverse$2(F);
    var out = function(f) {
        return function(ta) {
            return F.ap(F.map(f(ta.value), function(value) {
                return function(forest) {
                    return ({
                        value: value,
                        forest: forest
                    });
                };
            }), pipe$1(ta.forest, traverseF(out(f))));
        };
    };
    return out;
};
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function(F) {
    return traverse$1(F)(identity);
};
/**
 * @category constructors
 * @since 2.7.0
 */
var of = function(a) {
    return make$1(a);
};
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI$2 = 'Tree';
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.tree`
 * (where `T` is from `import T from 'fp-ts/Tree'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var tree = {
    URI: URI$2,
    map: _map$1,
    of: of ,
    ap: _ap,
    chain: flatMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    extract: extract,
    extend: _extend
};

/**
 * @category constructors
 * @since 2.0.0
 */
var make = unsafeCoerce;
/**
 * @category instances
 * @since 2.0.0
 */
function getApply(S) {
    return {
        URI: URI$1,
        _E: undefined,
        map: _map,
        ap: function(fab, fa) {
            return make(S.concat(fab, fa));
        }
    };
}
/**
 * @category instances
 * @since 2.0.0
 */
function getApplicative(M) {
    var A = getApply(M);
    return {
        URI: URI$1,
        _E: undefined,
        map: A.map,
        ap: A.ap,
        of: function() {
            return make(M.empty);
        }
    };
}
/* istanbul ignore next */
var _map = function(fa, f) {
    return pipe$1(fa, map());
};
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.0.0
 */
var map = function() {
    return unsafeCoerce;
};
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI$1 = 'Const';

/**
 * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */
var pipe = pipe$1;

var __spreadArray = (undefined && undefined.__spreadArray) || function(to, from, pack) {
    if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/** @internal */
var isoAsLens = function(sa) {
    return lens$2(sa.get, flow(sa.reverseGet, constant));
};
/** @internal */
var isoAsPrism = function(sa) {
    return prism(flow(sa.get, some$1), sa.reverseGet);
};
/** @internal */
var isoAsOptional = function(sa) {
    return optional(flow(sa.get, some$1), flow(sa.reverseGet, constant));
};
/** @internal */
var isoAsTraversal = function(sa) {
    return traversal(function(F) {
        return function(f) {
            return function(s) {
                return F.map(f(sa.get(s)), function(a) {
                    return sa.reverseGet(a);
                });
            };
        };
    });
};
// -------------------------------------------------------------------------------------
// Lens
// -------------------------------------------------------------------------------------
/** @internal */
var lens$2 = function(get, set) {
    return ({
        get: get,
        set: set
    });
};
/** @internal */
var lensAsOptional = function(sa) {
    return optional(flow(sa.get, some$1), sa.set);
};
/** @internal */
var lensAsTraversal = function(sa) {
    return traversal(function(F) {
        return function(f) {
            return function(s) {
                return F.map(f(sa.get(s)), function(a) {
                    return sa.set(a)(s);
                });
            };
        };
    });
};
/** @internal */
var lensComposeLens = function(ab) {
    return function(sa) {
        return lens$2(function(s) {
            return ab.get(sa.get(s));
        }, function(b) {
            return function(s) {
                return sa.set(ab.set(b)(sa.get(s)))(s);
            };
        });
    };
};
/** @internal */
var prismComposePrism = function(ab) {
    return function(sa) {
        return prism(flow(sa.getOption, chain(ab.getOption)), flow(ab.reverseGet, sa.reverseGet));
    };
};
/** @internal */
var lensComposePrism = function(ab) {
    return function(sa) {
        return optionalComposeOptional(prismAsOptional(ab))(lensAsOptional(sa));
    };
};
/** @internal */
var lensId = function() {
    return lens$2(identity, constant);
};
/** @internal */
var lensProp = function(prop) {
    return function(sa) {
        return lens$2(function(s) {
            return sa.get(s)[prop];
        }, function(ap) {
            return function(s) {
                var _a;
                var oa = sa.get(s);
                if (ap === oa[prop]) {
                    return s;
                }
                return sa.set(Object.assign({}, oa, (_a = {}, _a[prop] = ap, _a)))(s);
            };
        });
    };
};
/** @internal */
var lensProps = function() {
    var props = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
    }
    return function(sa) {
        return lens$2(function(s) {
            var a = sa.get(s);
            var r = {};
            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
                var k = props_1[_i];
                r[k] = a[k];
            }
            return r;
        }, function(a) {
            return function(s) {
                var oa = sa.get(s);
                for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {
                    var k = props_2[_i];
                    if (a[k] !== oa[k]) {
                        return sa.set(Object.assign({}, oa, a))(s);
                    }
                }
                return s;
            };
        });
    };
};
/** @internal */
var lensComponent = function(prop) {
    return function(sa) {
        return lens$2(function(s) {
            return sa.get(s)[prop];
        }, function(ap) {
            return function(s) {
                var oa = sa.get(s);
                if (ap === oa[prop]) {
                    return s;
                }
                var copy = oa.slice();
                copy[prop] = ap;
                return sa.set(copy)(s);
            };
        });
    };
};
/** @internal */
var lensAtKey = function(key) {
    return function(sa) {
        return pipe(sa, lensComposeLens(atReadonlyRecord().at(key)));
    };
};
// -------------------------------------------------------------------------------------
// Prism
// -------------------------------------------------------------------------------------
/** @internal */
var prism = function(getOption, reverseGet) {
    return ({
        getOption: getOption,
        reverseGet: reverseGet
    });
};
/** @internal */
var prismAsOptional = function(sa) {
    return optional(sa.getOption, function(a) {
        return prismSet(a)(sa);
    });
};
/** @internal */
var prismAsTraversal = function(sa) {
    return traversal(function(F) {
        return function(f) {
            return function(s) {
                return pipe(sa.getOption(s), fold$1(function() {
                    return F.of(s);
                }, function(a) {
                    return F.map(f(a), function(a) {
                        return prismSet(a)(sa)(s);
                    });
                }));
            };
        };
    });
};
/** @internal */
var prismModifyOption = function(f) {
    return function(sa) {
        return function(s) {
            return pipe(sa.getOption(s), map$2(function(o) {
                var n = f(o);
                return n === o ? s : sa.reverseGet(n);
            }));
        };
    };
};
/** @internal */
var prismModify = function(f) {
    return function(sa) {
        var g = prismModifyOption(f)(sa);
        return function(s) {
            return pipe(g(s), getOrElse(function() {
                return s;
            }));
        };
    };
};
/** @internal */
var prismSet = function(a) {
    return prismModify(function() {
        return a;
    });
};
/** @internal */
var prismComposeLens = function(ab) {
    return function(sa) {
        return optionalComposeOptional(lensAsOptional(ab))(prismAsOptional(sa));
    };
};
/** @internal */
var prismFromNullable = function() {
    return prism(fromNullable$1, identity);
};
/** @internal */
var prismFromPredicate = function(predicate) {
    return prism(fromPredicate$1(predicate), identity);
};
/** @internal */
var prismSome = function() {
    return prism(identity, some$1);
};
/** @internal */
var prismRight = function() {
    return prism(fromEither, right$1);
};
/** @internal */
var prismLeft = function() {
    return prism(function(s) {
            return (isLeft(s) ? some$1(s.left) : none);
        }, // TODO: replace with E.getLeft in v3
        left$1);
};
// -------------------------------------------------------------------------------------
// Optional
// -------------------------------------------------------------------------------------
/** @internal */
var optional = function(getOption, set) {
    return ({
        getOption: getOption,
        set: set
    });
};
/** @internal */
var optionalAsTraversal = function(sa) {
    return traversal(function(F) {
        return function(f) {
            return function(s) {
                return pipe(sa.getOption(s), fold$1(function() {
                    return F.of(s);
                }, function(a) {
                    return F.map(f(a), function(a) {
                        return sa.set(a)(s);
                    });
                }));
            };
        };
    });
};
/** @internal */
var optionalModifyOption = function(f) {
    return function(optional) {
        return function(s) {
            return pipe(optional.getOption(s), map$2(function(a) {
                var n = f(a);
                return n === a ? s : optional.set(n)(s);
            }));
        };
    };
};
/** @internal */
var optionalModify = function(f) {
    return function(optional) {
        var g = optionalModifyOption(f)(optional);
        return function(s) {
            return pipe(g(s), getOrElse(function() {
                return s;
            }));
        };
    };
};
/** @internal */
var optionalComposeOptional = function(ab) {
    return function(sa) {
        return optional(flow(sa.getOption, chain(ab.getOption)), function(b) {
            return optionalModify(ab.set(b))(sa);
        });
    };
};
/** @internal */
var optionalIndex = function(i) {
    return function(sa) {
        return pipe(sa, optionalComposeOptional(indexReadonlyArray().index(i)));
    };
};
/** @internal */
var optionalIndexNonEmpty = function(i) {
    return function(sa) {
        return pipe(sa, optionalComposeOptional(indexReadonlyNonEmptyArray().index(i)));
    };
};
/** @internal */
var optionalKey = function(key) {
    return function(sa) {
        return pipe(sa, optionalComposeOptional(indexReadonlyRecord().index(key)));
    };
};
/** @internal */
var optionalFindFirst = function(predicate) {
    return optional(findFirst$1(predicate), function(a) {
        return function(s) {
            return pipe(findIndex(predicate)(s), fold$1(function() {
                return s;
            }, function(i) {
                return unsafeUpdateAt$1(i, a, s);
            }));
        };
    });
};
var unsafeUpdateAt = function(i, a, as) {
    if (as[i] === a) {
        return as;
    } else {
        var xs = __spreadArray([as[0]], as.slice(1), true);
        xs[i] = a;
        return xs;
    }
};
/** @internal */
var optionalFindFirstNonEmpty = function(predicate) {
    return optional(findFirst$1(predicate), function(a) {
        return function(as) {
            return pipe(findIndex(predicate)(as), fold$1(function() {
                return as;
            }, function(i) {
                return unsafeUpdateAt(i, a, as);
            }));
        };
    });
};
// -------------------------------------------------------------------------------------
// Traversal
// -------------------------------------------------------------------------------------
/** @internal */
var traversal = function(modifyF) {
    return ({
        modifyF: modifyF
    });
};
/** @internal */
function traversalComposeTraversal(ab) {
    return function(sa) {
        return traversal(function(F) {
            return function(f) {
                return sa.modifyF(F)(ab.modifyF(F)(f));
            };
        });
    };
}
/** @internal */
var ApplicativeIdentity = {
    URI: 'Identity',
    map: function(fa, f) {
        return f(fa);
    },
    of: identity,
    ap:
        /* istanbul ignore next */
        function(fab, fa) {
            return fab(fa);
        }
};
var isIdentity = function(F) {
    return F.URI === 'Identity';
};

function fromTraversable$2(T) {
    return function() {
        return traversal(function(F) {
            // if `F` is `Identity` then `traverseF = map`
            var traverseF = isIdentity(F) ?
                T.map :
                T.traverse(F);
            return function(f) {
                return function(s) {
                    return traverseF(s, f);
                };
            };
        });
    };
}
/** @internal */
function traversalTraverse(T) {
    return traversalComposeTraversal(fromTraversable$2(T)());
}
// -------------------------------------------------------------------------------------
// Ix
// -------------------------------------------------------------------------------------
/** @internal */
var index$1 = function(index) {
    return ({
        index: index
    });
};
/** @internal */
var indexReadonlyArray = function() {
    return index$1(function(i) {
        return optional(function(as) {
            return lookup(i, as);
        }, function(a) {
            return function(as) {
                return pipe(lookup(i, as), fold$1(function() {
                    return as;
                }, function() {
                    return unsafeUpdateAt$1(i, a, as);
                }));
            };
        });
    });
};
/** @internal */
var indexReadonlyNonEmptyArray = function() {
    return index$1(function(i) {
        return optional(function(as) {
            return lookup(i, as);
        }, function(a) {
            return function(as) {
                return pipe(lookup(i, as), fold$1(function() {
                    return as;
                }, function() {
                    return unsafeUpdateAt(i, a, as);
                }));
            };
        });
    });
};
/** @internal */
var indexReadonlyRecord = function() {
    return index$1(function(k) {
        return optional(function(r) {
            return lookup$1(k, r);
        }, function(a) {
            return function(r) {
                if (r[k] === a || isNone(lookup$1(k, r))) {
                    return r;
                }
                return insertAt(k, a)(r);
            };
        });
    });
};
// -------------------------------------------------------------------------------------
// At
// -------------------------------------------------------------------------------------
/** @internal */
var at = function(at) {
    return ({
        at: at
    });
};
/** @internal */
function atReadonlyRecord() {
    return at(function(key) {
        return lens$2(function(r) {
            return lookup$1(key, r);
        }, fold$1(function() {
            return deleteAt(key);
        }, function(a) {
            return insertAt(key, a);
        }));
    });
}

// -------------------------------------------------------------------------------------
// converters
// -------------------------------------------------------------------------------------
/**
 * View an `Iso` as a `Lens`.
 *
 * @category converters
 * @since 2.3.0
 */
var asLens = isoAsLens;
/**
 * View an `Iso` as a `Prism`.
 *
 * @category converters
 * @since 2.3.0
 */
var asPrism = isoAsPrism;
/**
 * View an `Iso` as a `Optional`.
 *
 * @category converters
 * @since 2.3.0
 */
var asOptional$2 = isoAsOptional;
/**
 * View an `Iso` as a `Traversal`.
 *
 * @category converters
 * @since 2.3.0
 */
var asTraversal$3 = isoAsTraversal;

// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.3.8
 */
var lens = lens$2;
/**
 * @category constructors
 * @since 2.3.0
 */
var id = lensId;
// -------------------------------------------------------------------------------------
// converters
// -------------------------------------------------------------------------------------
/**
 * View a `Lens` as a `Optional`.
 *
 * @category converters
 * @since 2.3.0
 */
var asOptional$1 = lensAsOptional;
/**
 * View a `Lens` as a `Traversal`.
 *
 * @category converters
 * @since 2.3.0
 */
var asTraversal$2 = lensAsTraversal;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Lens` with a `Lens`.
 *
 * @category compositions
 * @since 2.3.0
 */
var compose$3 = lensComposeLens;
/**
 * Alias of `compose`.
 *
 * @category compositions
 * @since 2.3.8
 */
var composeLens$1 = compose$3;
/**
 * Compose a `Lens` with a `Iso`.
 *
 * @category compositions
 * @since 2.3.8
 */
var composeIso =
    /*#__PURE__*/
    flow(isoAsLens, compose$3);
/**
 * Compose a `Lens` with a `Prism`.
 *
 * @category compositions
 * @since 2.3.0
 */
var composePrism = lensComposePrism;
/**
 * Compose a `Lens` with an `Optional`.
 *
 * @category compositions
 * @since 2.3.0
 */
var composeOptional = function(ab) {
    return flow(asOptional$1, optionalComposeOptional(ab));
};
/**
 * Compose a `Lens` with an `Traversal`.
 *
 * @category compositions
 * @since 2.3.8
 */
var composeTraversal = function(ab) {
    return flow(asTraversal$2, traversalComposeTraversal(ab));
};
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category combinators
 * @since 2.3.0
 */
var modify$2 = function(f) {
    return function(sa) {
        return function(s) {
            var o = sa.get(s);
            var n = f(o);
            return o === n ? s : sa.set(n)(s);
        };
    };
};

function modifyF(F) {
    return function(f) {
        return function(sa) {
            return function(s) {
                return pipe(sa.get(s), f, function(fa) {
                    return F.map(fa, function(a) {
                        return sa.set(a)(s);
                    });
                });
            };
        };
    };
}
/**
 * Return a `Optional` from a `Lens` focused on a nullable value.
 *
 * @category combinators
 * @since 2.3.0
 */
var fromNullable = function(sa) {
    return composePrism(prismFromNullable())(sa);
};

function filter$1(predicate) {
    return composePrism(prismFromPredicate(predicate));
}
/**
 * Return a `Lens` from a `Lens` and a prop.
 *
 * @category combinators
 * @since 2.3.0
 */
var prop = lensProp;
/**
 * Return a `Lens` from a `Lens` and a list of props.
 *
 * @category combinators
 * @since 2.3.0
 */
var props = lensProps;
/**
 * Return a `Lens` from a `Lens` focused on a component of a tuple.
 *
 * @category combinators
 * @since 2.3.0
 */
var component = lensComponent;
/**
 * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyArray`.
 *
 * @category combinators
 * @since 2.3.0
 */
var index = function(i) {
    return flow(asOptional$1, optionalIndex(i));
};
/**
 * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyNonEmptyArray`.
 *
 * @category combinators
 * @since 2.3.8
 */
var indexNonEmpty = function(i) {
    return flow(asOptional$1, optionalIndexNonEmpty(i));
};
/**
 * Return a `Optional` from a `Lens` focused on a key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
var key = function(key) {
    return flow(asOptional$1, optionalKey(key));
};
/**
 * Return a `Lens` from a `Lens` focused on a required key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
var atKey = lensAtKey;
/**
 * Return a `Optional` from a `Lens` focused on the `Some` of a `Option` type.
 *
 * @category combinators
 * @since 2.3.0
 */
var some =
    /*#__PURE__*/
    composePrism( /*#__PURE__*/ prismSome());
/**
 * Return a `Optional` from a `Lens` focused on the `Right` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
var right =
    /*#__PURE__*/
    composePrism( /*#__PURE__*/ prismRight());
/**
 * Return a `Optional` from a `Lens` focused on the `Left` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
var left =
    /*#__PURE__*/
    composePrism( /*#__PURE__*/ prismLeft());
/**
 * Return a `Traversal` from a `Lens` focused on a `Traversable`.
 *
 * @category combinators
 * @since 2.3.0
 */
function traverse(T) {
    return flow(asTraversal$2, traversalTraverse(T));
}

function findFirst(predicate) {
    return composeOptional(optionalFindFirst(predicate));
}

function findFirstNonEmpty(predicate) {
    return composeOptional(optionalFindFirstNonEmpty(predicate));
}
// -------------------------------------------------------------------------------------
// pipeables
// -------------------------------------------------------------------------------------
/**
 * @category Invariant
 * @since 2.3.0
 */
var imap = function(f, g) {
    return function(ea) {
        return imap_(ea, f, g);
    };
};
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
var imap_ = function(ea, ab, ba) {
    return lens(flow(ea.get, ab), flow(ba, ea.set));
};
/**
 * @category instances
 * @since 2.3.0
 */
var URI = 'monocle-ts/Lens';
/**
 * @category instances
 * @since 2.3.0
 */
var Invariant = {
    URI: URI,
    imap: imap_
};
/**
 * @category instances
 * @since 2.3.8
 */
var Semigroupoid = {
    URI: URI,
    compose: function(ab, ea) {
        return compose$3(ab)(ea);
    }
};
/**
 * @category instances
 * @since 2.3.0
 */
var Category = {
    URI: URI,
    compose: Semigroupoid.compose,
    id: id
};

var lens$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Category: Category,
    Invariant: Invariant,
    Semigroupoid: Semigroupoid,
    URI: URI,
    asOptional: asOptional$1,
    asTraversal: asTraversal$2,
    atKey: atKey,
    component: component,
    compose: compose$3,
    composeIso: composeIso,
    composeLens: composeLens$1,
    composeOptional: composeOptional,
    composePrism: composePrism,
    composeTraversal: composeTraversal,
    filter: filter$1,
    findFirst: findFirst,
    findFirstNonEmpty: findFirstNonEmpty,
    fromNullable: fromNullable,
    id: id,
    imap: imap,
    index: index,
    indexNonEmpty: indexNonEmpty,
    key: key,
    left: left,
    lens: lens,
    modify: modify$2,
    modifyF: modifyF,
    prop: prop,
    props: props,
    right: right,
    some: some,
    traverse: traverse
});

// -------------------------------------------------------------------------------------
// converters
// -------------------------------------------------------------------------------------
/**
 * View a `Optional` as a `Traversal`.
 *
 * @category converters
 * @since 2.3.0
 */
var asTraversal$1 = optionalAsTraversal;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Optional` with a `Optional`.
 *
 * @category compositions
 * @since 2.3.0
 */
var compose$2 = optionalComposeOptional;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category combinators
 * @since 2.3.0
 */
var modifyOption = optionalModifyOption;
/**
 * @category combinators
 * @since 2.3.0
 */
var modify$1 = optionalModify;

/**
 * @category constructors
 * @since 2.3.0
 */
var fromPredicate = prismFromPredicate;
// -------------------------------------------------------------------------------------
// converters
// -------------------------------------------------------------------------------------
/**
 * View a `Prism` as a `Optional`.
 *
 * @category converters
 * @since 2.3.0
 */
var asOptional = prismAsOptional;
/**
 * View a `Prism` as a `Traversal`.
 *
 * @category converters
 * @since 2.3.0
 */
var asTraversal = prismAsTraversal;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Prism` with a `Prism`.
 *
 * @category compositions
 * @since 2.3.0
 */
var compose$1 = prismComposePrism;
/**
 * Compose a `Prism` with a `Lens`.
 *
 * @category compositions
 * @since 2.3.0
 */
var composeLens = prismComposeLens;

/**
 * Create a `Traversal` from a `Traversable`.
 *
 * @category constructor
 * @since 2.3.0
 */
var fromTraversable$1 = fromTraversable$2;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Traversal` with a `Traversal`.
 *
 * @category compositions
 * @since 2.3.0
 */
var compose = traversalComposeTraversal;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category combinators
 * @since 2.3.0
 */
var modify = function(f) {
    return function(sa) {
        return sa.modifyF(ApplicativeIdentity)(f);
    };
};
/**
 * @category combinators
 * @since 2.3.0
 */
var set = function(a) {
    return modify(function() {
        return a;
    });
};

function filter(predicate) {
    return compose(prismAsTraversal(prismFromPredicate(predicate)));
}

/**
 * @since 1.0.0
 */
var fromLens = function(lens) {
    return new Lens(lens.get, lens.set);
};
var fromPrism = function(prism) {
    return new Prism(prism.getOption, prism.reverseGet);
};
var fromOptional = function(optional) {
    return new Optional(optional.getOption, optional.set);
};
var fromTraversal = function(traversal) {
    return new Traversal(traversal.modifyF);
};
//
// old APIs
//
var update = function(o, k, a) {
    var _a;
    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));
};
/**
 * Laws:
 * 1. `get(set(a)(s)) = a`
 * 2. `set(get(s))(s) = s`
 * 3. `set(a)(set(a)(s)) = set(a)(s)`
 *
 * @category constructor
 * @since 1.0.0
 */
var Lens = /** @class */ (function() {
    function Lens(get, set) {
        this.get = get;
        this.set = set;
        /**
         * @since 1.0.0
         */
        this._tag = 'Lens';
    }
    /**
     * @example
     * import { Lens } from 'monocle-ts'
     *
     * type Person = {
     *   name: string
     *   age: number
     *   address: {
     *     city: string
     *   }
     * }
     *
     * const city = Lens.fromPath<Person>()(['address', 'city'])
     *
     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }
     *
     * assert.strictEqual(city.get(person), 'Milan')
     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })
     *
     * @since 1.0.0
     */
    Lens.fromPath = function() {
        var fromProp = Lens.fromProp();
        return function(path) {
            var lens = fromProp(path[0]);
            return path.slice(1).reduce(function(acc, prop) {
                return acc.compose(fromProp(prop));
            }, lens);
        };
    };
    /**
     * Returns a `Lens` from a type and a prop
     *
     * @example
     * import { Lens } from 'monocle-ts'
     *
     * type Person = {
     *   name: string
     *   age: number
     * }
     *
     * const age = Lens.fromProp<Person>()('age')
     *
     * const person: Person = { name: 'Giulio', age: 43 }
     *
     * assert.strictEqual(age.get(person), 43)
     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })
     *
     * @since 1.0.0
     */
    Lens.fromProp = function() {
        return function(prop$1) {
            return fromLens(pipe(id(), prop(prop$1)));
        };
    };
    Lens.fromProps = function() {
        return function(props$1) {
            return fromLens(pipe(id(), props.apply(lens$1, props$1)));
        };
    };
    /**
     * Returns a `Lens` from a nullable (`A | null | undefined`) prop
     *
     * @example
     * import { Lens } from 'monocle-ts'
     *
     * interface Outer {
     *   inner?: Inner
     * }
     *
     * interface Inner {
     *   value: number
     *   foo: string
     * }
     *
     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })
     * const value = Lens.fromProp<Inner>()('value')
     * const lens = inner.compose(value)
     *
     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })
     * assert.strictEqual(lens.get({}), 0)
     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })
     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)
     *
     * @since 1.0.0
     */
    Lens.fromNullableProp = function() {
        return function(k, defaultValue) {
            return new Lens(function(s) {
                var osk = fromNullable$1(s[k]);
                if (isNone(osk)) {
                    return defaultValue;
                } else {
                    return osk.value;
                }
            }, function(a) {
                return function(s) {
                    return update(s, k, a);
                };
            });
        };
    };
    /**
     * @since 1.0.0
     */
    Lens.prototype.modify = function(f) {
        return modify$2(f)(this);
    };
    /**
     * view a `Lens` as a Optional
     *
     * @since 1.0.0
     */
    Lens.prototype.asOptional = function() {
        return fromOptional(asOptional$1(this));
    };
    /**
     * view a `Lens` as a `Traversal`
     *
     * @since 1.0.0
     */
    Lens.prototype.asTraversal = function() {
        return fromTraversal(asTraversal$2(this));
    };
    /**
     * view a `Lens` as a `Setter`
     *
     * @since 1.0.0
     */
    Lens.prototype.asSetter = function() {
        var _this = this;
        return new Setter(function(f) {
            return _this.modify(f);
        });
    };
    /**
     * view a `Lens` as a `Getter`
     *
     * @since 1.0.0
     */
    Lens.prototype.asGetter = function() {
        var _this = this;
        return new Getter(function(s) {
            return _this.get(s);
        });
    };
    /**
     * view a `Lens` as a `Fold`
     *
     * @since 1.0.0
     */
    Lens.prototype.asFold = function() {
        var _this = this;
        return new Fold(function() {
            return function(f) {
                return function(s) {
                    return f(_this.get(s));
                };
            };
        });
    };
    /**
     * compose a `Lens` with a `Lens`
     *
     * @since 1.0.0
     */
    Lens.prototype.compose = function(ab) {
        return fromLens(compose$3(ab)(this));
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeLens = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Lens` with a `Getter`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeGetter = function(ab) {
        return this.asGetter().compose(ab);
    };
    /**
     * compose a `Lens` with a `Fold`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeFold = function(ab) {
        return this.asFold().compose(ab);
    };
    /**
     * compose a `Lens` with an `Optional`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeOptional = function(ab) {
        return fromOptional(pipe(this, asOptional$1, compose$2(ab)));
    };
    /**
     * compose a `Lens` with an `Traversal`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeTraversal = function(ab) {
        return fromTraversal(pipe(this, asTraversal$2, compose(ab)));
    };
    /**
     * compose a `Lens` with an `Setter`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeSetter = function(ab) {
        return this.asSetter().compose(ab);
    };
    /**
     * compose a `Lens` with an `Iso`
     *
     * @since 1.0.0
     */
    Lens.prototype.composeIso = function(ab) {
        return fromLens(pipe(this, compose$3(pipe(ab, asLens))));
    };
    /**
     * compose a `Lens` with a `Prism`
     *
     * @since 1.0.0
     */
    Lens.prototype.composePrism = function(ab) {
        return fromOptional(composePrism(ab)(this));
    };
    return Lens;
}());
/**
 * Laws:
 * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`
 * 2. `getOption(reverseGet(a)) = some(a)`
 *
 * @category constructor
 * @since 1.0.0
 */
var Prism = /** @class */ (function() {
    function Prism(getOption, reverseGet) {
        this.getOption = getOption;
        this.reverseGet = reverseGet;
        /**
         * @since 1.0.0
         */
        this._tag = 'Prism';
    }
    Prism.fromPredicate = function(predicate) {
        return fromPrism(fromPredicate(predicate));
    };
    /**
     * @since 1.0.0
     */
    Prism.some = function() {
        return somePrism;
    };
    /**
     * @since 1.0.0
     */
    Prism.prototype.modify = function(f) {
        var _this = this;
        return function(s) {
            var os = _this.modifyOption(f)(s);
            if (isNone(os)) {
                return s;
            } else {
                return os.value;
            }
        };
    };
    /**
     * @since 1.0.0
     */
    Prism.prototype.modifyOption = function(f) {
        var _this = this;
        return function(s) {
            return option.map(_this.getOption(s), function(v) {
                var n = f(v);
                return n === v ? s : _this.reverseGet(n);
            });
        };
    };
    /**
     * set the target of a `Prism` with a value
     *
     * @since 1.0.0
     */
    Prism.prototype.set = function(a) {
        return this.modify(function() {
            return a;
        });
    };
    /**
     * view a `Prism` as a `Optional`
     *
     * @since 1.0.0
     */
    Prism.prototype.asOptional = function() {
        return fromOptional(asOptional(this));
    };
    /**
     * view a `Prism` as a `Traversal`
     *
     * @since 1.0.0
     */
    Prism.prototype.asTraversal = function() {
        return fromTraversal(asTraversal(this));
    };
    /**
     * view a `Prism` as a `Setter`
     *
     * @since 1.0.0
     */
    Prism.prototype.asSetter = function() {
        var _this = this;
        return new Setter(function(f) {
            return _this.modify(f);
        });
    };
    /**
     * view a `Prism` as a `Fold`
     *
     * @since 1.0.0
     */
    Prism.prototype.asFold = function() {
        var _this = this;
        return new Fold(function(M) {
            return function(f) {
                return function(s) {
                    var oa = _this.getOption(s);
                    return isNone(oa) ? M.empty : f(oa.value);
                };
            };
        });
    };
    /**
     * compose a `Prism` with a `Prism`
     *
     * @since 1.0.0
     */
    Prism.prototype.compose = function(ab) {
        return fromPrism(compose$1(ab)(this));
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Prism.prototype.composePrism = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Prism` with a `Optional`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeOptional = function(ab) {
        return fromOptional(pipe(this, asOptional, compose$2(ab)));
    };
    /**
     * compose a `Prism` with a `Traversal`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeTraversal = function(ab) {
        return fromTraversal(pipe(this, asTraversal, compose(ab)));
    };
    /**
     * compose a `Prism` with a `Fold`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeFold = function(ab) {
        return this.asFold().compose(ab);
    };
    /**
     * compose a `Prism` with a `Setter`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeSetter = function(ab) {
        return this.asSetter().compose(ab);
    };
    /**
     * compose a `Prism` with a `Iso`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeIso = function(ab) {
        return fromPrism(pipe(this, compose$1(pipe(ab, asPrism))));
    };
    /**
     * compose a `Prism` with a `Lens`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeLens = function(ab) {
        return fromOptional(composeLens(ab)(this));
    };
    /**
     * compose a `Prism` with a `Getter`
     *
     * @since 1.0.0
     */
    Prism.prototype.composeGetter = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    return Prism;
}());
var somePrism =
    /*#__PURE__*/
    new Prism(identity, some$1);
/**
 * Laws:
 * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`
 * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`
 * 3. `set(a)(set(a)(s)) = set(a)(s)`
 *
 * @category constructor
 * @since 1.0.0
 */
var Optional = /** @class */ (function() {
    function Optional(getOption, set) {
        this.getOption = getOption;
        this.set = set;
        /**
         * @since 1.0.0
         */
        this._tag = 'Optional';
    }
    /**
     * Returns an `Optional` from a nullable (`A | null | undefined`) prop
     *
     * @example
     * import { Optional } from 'monocle-ts'
     *
     * interface Phone {
     *   number: string
     * }
     * interface Employment {
     *   phone?: Phone
     * }
     * interface Info {
     *   employment?: Employment
     * }
     * interface Response {
     *   info?: Info
     * }
     *
     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])
     *
     * const response1: Response = {
     *   info: {
     *     employment: {
     *       phone: {
     *         number: '555-1234'
     *       }
     *     }
     *   }
     * }
     * const response2: Response = {
     *   info: {
     *     employment: {}
     *   }
     * }
     *
     * numberFromResponse.getOption(response1) // some('555-1234')
     * numberFromResponse.getOption(response2) // none
     *
     * @since 2.1.0
     */
    Optional.fromPath = function() {
        var fromNullableProp = Optional.fromNullableProp();
        return function(path) {
            var optional = fromNullableProp(path[0]);
            return path.slice(1).reduce(function(acc, prop) {
                return acc.compose(fromNullableProp(prop));
            }, optional);
        };
    };
    /**
     * @example
     * import { Optional } from 'monocle-ts'
     *
     * interface S {
     *   a: number | undefined | null
     * }
     *
     * const optional = Optional.fromNullableProp<S>()('a')
     *
     * const s1: S = { a: undefined }
     * const s2: S = { a: null }
     * const s3: S = { a: 1 }
     *
     * assert.deepStrictEqual(optional.set(2)(s1), s1)
     * assert.deepStrictEqual(optional.set(2)(s2), s2)
     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })
     *
     * @since 1.0.0
     */
    Optional.fromNullableProp = function() {
        return function(k) {
            return new Optional(function(s) {
                return fromNullable$1(s[k]);
            }, function(a) {
                return function(s) {
                    return (s[k] == null ? s : update(s, k, a));
                };
            });
        };
    };
    /**
     * Returns an `Optional` from an option (`Option<A>`) prop
     *
     * @example
     * import { Optional } from 'monocle-ts'
     * import * as O from 'fp-ts/Option'
     *
     * interface S {
     *   a: O.Option<number>
     * }
     *
     * const optional = Optional.fromOptionProp<S>()('a')
     * const s1: S = { a: O.none }
     * const s2: S = { a: O.some(1) }
     * assert.deepStrictEqual(optional.set(2)(s1), s1)
     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })
     *
     * @since 1.0.0
     */
    Optional.fromOptionProp = function() {
        var formProp = Lens.fromProp();
        return function(prop) {
            return formProp(prop).composePrism(somePrism);
        };
    };
    /**
     * @since 1.0.0
     */
    Optional.prototype.modify = function(f) {
        return modify$1(f)(this);
    };
    /**
     * @since 1.0.0
     */
    Optional.prototype.modifyOption = function(f) {
        return modifyOption(f)(this);
    };
    /**
     * view a `Optional` as a `Traversal`
     *
     * @since 1.0.0
     */
    Optional.prototype.asTraversal = function() {
        return fromTraversal(asTraversal$1(this));
    };
    /**
     * view an `Optional` as a `Fold`
     *
     * @since 1.0.0
     */
    Optional.prototype.asFold = function() {
        var _this = this;
        return new Fold(function(M) {
            return function(f) {
                return function(s) {
                    var oa = _this.getOption(s);
                    return isNone(oa) ? M.empty : f(oa.value);
                };
            };
        });
    };
    /**
     * view an `Optional` as a `Setter`
     *
     * @since 1.0.0
     */
    Optional.prototype.asSetter = function() {
        var _this = this;
        return new Setter(function(f) {
            return _this.modify(f);
        });
    };
    /**
     * compose a `Optional` with a `Optional`
     *
     * @since 1.0.0
     */
    Optional.prototype.compose = function(ab) {
        return fromOptional(compose$2(ab)(this));
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeOptional = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose an `Optional` with a `Traversal`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeTraversal = function(ab) {
        return fromTraversal(pipe(this, asTraversal$1, compose(ab)));
    };
    /**
     * compose an `Optional` with a `Fold`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeFold = function(ab) {
        return this.asFold().compose(ab);
    };
    /**
     * compose an `Optional` with a `Setter`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeSetter = function(ab) {
        return this.asSetter().compose(ab);
    };
    /**
     * compose an `Optional` with a `Lens`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeLens = function(ab) {
        return fromOptional(pipe(this, compose$2(pipe(ab, asOptional$1))));
    };
    /**
     * compose an `Optional` with a `Prism`
     *
     * @since 1.0.0
     */
    Optional.prototype.composePrism = function(ab) {
        return fromOptional(pipe(this, compose$2(pipe(ab, asOptional))));
    };
    /**
     * compose an `Optional` with a `Iso`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeIso = function(ab) {
        return fromOptional(pipe(this, compose$2(pipe(ab, asOptional$2))));
    };
    /**
     * compose an `Optional` with a `Getter`
     *
     * @since 1.0.0
     */
    Optional.prototype.composeGetter = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    return Optional;
}());
/**
 * @category constructor
 * @since 1.0.0
 */
var Traversal = /** @class */ (function() {
    function Traversal(
        // Van Laarhoven representation
        modifyF) {
        this.modifyF = modifyF;
        /**
         * @since 1.0.0
         */
        this._tag = 'Traversal';
    }
    /**
     * @since 1.0.0
     */
    Traversal.prototype.modify = function(f) {
        return modify(f)(this);
    };
    /**
     * @since 1.0.0
     */
    Traversal.prototype.set = function(a) {
        return set(a)(this);
    };
    Traversal.prototype.filter = function(predicate) {
        return fromTraversal(filter(predicate)(this));
    };
    /**
     * view a `Traversal` as a `Fold`
     *
     * @since 1.0.0
     */
    Traversal.prototype.asFold = function() {
        var _this = this;
        return new Fold(function(M) {
            return function(f) {
                return _this.modifyF(getApplicative(M))(function(a) {
                    return make(f(a));
                });
            };
        });
    };
    /**
     * view a `Traversal` as a `Setter`
     *
     * @since 1.0.0
     */
    Traversal.prototype.asSetter = function() {
        var _this = this;
        return new Setter(function(f) {
            return _this.modify(f);
        });
    };
    /**
     * compose a `Traversal` with a `Traversal`
     *
     * @since 1.0.0
     */
    Traversal.prototype.compose = function(ab) {
        return fromTraversal(compose(ab)(this));
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeTraversal = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Traversal` with a `Fold`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeFold = function(ab) {
        return this.asFold().compose(ab);
    };
    /**
     * compose a `Traversal` with a `Setter`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeSetter = function(ab) {
        return this.asSetter().compose(ab);
    };
    /**
     * compose a `Traversal` with a `Optional`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeOptional = function(ab) {
        return this.compose(ab.asTraversal());
    };
    /**
     * compose a `Traversal` with a `Lens`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeLens = function(ab) {
        return fromTraversal(pipe(this, compose(pipe(ab, asTraversal$2))));
    };
    /**
     * compose a `Traversal` with a `Prism`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composePrism = function(ab) {
        return fromTraversal(pipe(this, compose(pipe(ab, asTraversal))));
    };
    /**
     * compose a `Traversal` with a `Iso`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeIso = function(ab) {
        return fromTraversal(pipe(this, compose(pipe(ab, asTraversal$3))));
    };
    /**
     * compose a `Traversal` with a `Getter`
     *
     * @since 1.0.0
     */
    Traversal.prototype.composeGetter = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    return Traversal;
}());
/**
 * @category constructor
 * @since 1.0.0
 */
var Getter = /** @class */ (function() {
    function Getter(get) {
        this.get = get;
        /**
         * @since 1.0.0
         */
        this._tag = 'Getter';
    }
    /**
     * view a `Getter` as a `Fold`
     *
     * @since 1.0.0
     */
    Getter.prototype.asFold = function() {
        var _this = this;
        return new Fold(function() {
            return function(f) {
                return function(s) {
                    return f(_this.get(s));
                };
            };
        });
    };
    /**
     * compose a `Getter` with a `Getter`
     *
     * @since 1.0.0
     */
    Getter.prototype.compose = function(ab) {
        var _this = this;
        return new Getter(function(s) {
            return ab.get(_this.get(s));
        });
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeGetter = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Getter` with a `Fold`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeFold = function(ab) {
        return this.asFold().compose(ab);
    };
    /**
     * compose a `Getter` with a `Lens`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeLens = function(ab) {
        return this.compose(ab.asGetter());
    };
    /**
     * compose a `Getter` with a `Iso`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeIso = function(ab) {
        return this.compose(ab.asGetter());
    };
    /**
     * compose a `Getter` with a `Optional`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeTraversal = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    /**
     * compose a `Getter` with a `Optional`
     *
     * @since 1.0.0
     */
    Getter.prototype.composeOptional = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    /**
     * compose a `Getter` with a `Prism`
     *
     * @since 1.0.0
     */
    Getter.prototype.composePrism = function(ab) {
        return this.asFold().compose(ab.asFold());
    };
    return Getter;
}());
/**
 * @category constructor
 * @since 1.0.0
 */
var Fold = /** @class */ (function() {
    function Fold(foldMap) {
        this.foldMap = foldMap;
        /**
         * @since 1.0.0
         */
        this._tag = 'Fold';
        this.getAll = foldMap(getMonoid())(of$1);
        this.exist = foldMap(monoidAny);
        this.all = foldMap(monoidAll);
        this.foldMapFirst = foldMap(getFirstMonoid());
    }
    /**
     * compose a `Fold` with a `Fold`
     *
     * @since 1.0.0
     */
    Fold.prototype.compose = function(ab) {
        var _this = this;
        return new Fold(function(M) {
            return function(f) {
                return _this.foldMap(M)(ab.foldMap(M)(f));
            };
        });
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeFold = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Fold` with a `Getter`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeGetter = function(ab) {
        return this.compose(ab.asFold());
    };
    /**
     * compose a `Fold` with a `Traversal`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeTraversal = function(ab) {
        return this.compose(ab.asFold());
    };
    /**
     * compose a `Fold` with a `Optional`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeOptional = function(ab) {
        return this.compose(ab.asFold());
    };
    /**
     * compose a `Fold` with a `Lens`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeLens = function(ab) {
        return this.compose(ab.asFold());
    };
    /**
     * compose a `Fold` with a `Prism`
     *
     * @since 1.0.0
     */
    Fold.prototype.composePrism = function(ab) {
        return this.compose(ab.asFold());
    };
    /**
     * compose a `Fold` with a `Iso`
     *
     * @since 1.0.0
     */
    Fold.prototype.composeIso = function(ab) {
        return this.compose(ab.asFold());
    };
    Fold.prototype.find = function(p) {
        return this.foldMapFirst(fromPredicate$1(p));
    };
    /**
     * get the first target of a `Fold`
     *
     * @since 1.0.0
     */
    Fold.prototype.headOption = function(s) {
        return this.find(function() {
            return true;
        })(s);
    };
    return Fold;
}());
/**
 * @category constructor
 * @since 1.0.0
 */
var Setter = /** @class */ (function() {
    function Setter(modify) {
        this.modify = modify;
        /**
         * @since 1.0.0
         */
        this._tag = 'Setter';
    }
    /**
     * @since 1.0.0
     */
    Setter.prototype.set = function(a) {
        return this.modify(constant(a));
    };
    /**
     * compose a `Setter` with a `Setter`
     *
     * @since 1.0.0
     */
    Setter.prototype.compose = function(ab) {
        var _this = this;
        return new Setter(function(f) {
            return _this.modify(ab.modify(f));
        });
    };
    /**
     * Alias of `compose`
     *
     * @since 1.0.0
     */
    Setter.prototype.composeSetter = function(ab) {
        return this.compose(ab);
    };
    /**
     * compose a `Setter` with a `Traversal`
     *
     * @since 1.0.0
     */
    Setter.prototype.composeTraversal = function(ab) {
        return this.compose(ab.asSetter());
    };
    /**
     * compose a `Setter` with a `Optional`
     *
     * @since 1.0.0
     */
    Setter.prototype.composeOptional = function(ab) {
        return this.compose(ab.asSetter());
    };
    /**
     * compose a `Setter` with a `Lens`
     *
     * @since 1.0.0
     */
    Setter.prototype.composeLens = function(ab) {
        return this.compose(ab.asSetter());
    };
    /**
     * compose a `Setter` with a `Prism`
     *
     * @since 1.0.0
     */
    Setter.prototype.composePrism = function(ab) {
        return this.compose(ab.asSetter());
    };
    /**
     * compose a `Setter` with a `Iso`
     *
     * @since 1.0.0
     */
    Setter.prototype.composeIso = function(ab) {
        return this.compose(ab.asSetter());
    };
    return Setter;
}());

function fromTraversable(T) {
    var f = fromTraversable$1(T);
    return function() {
        return fromTraversal(f());
    };
}

export {
    Lens as L, Prism as P, fold as a, fromTraversable as f, tree as t, unfoldTree as u
};
//# sourceMappingURL=index-907c0cc3.js.map