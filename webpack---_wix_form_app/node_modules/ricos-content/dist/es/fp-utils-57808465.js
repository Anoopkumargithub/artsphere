import {
    d as fold,
    m as map,
    u as fromPredicate,
    e as map$1,
    c as concatAll,
    v as ap,
    w as fromNullable,
    t as tryCatch,
    x as concatAll$1,
    l as left,
    p as of ,
    y as getSemigroup,
    f as first
} from './Option-87dfe66c.js';
import {
    p as pipe,
    i as identity
} from './ReadonlyNonEmptyArray-3599e877.js';

// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * @category refinements
 * @since 2.11.0
 */
/**
 * `boolean` semigroup under conjunction.
 *
 * @example
 * import { SemigroupAll } from 'fp-ts/boolean'
 *
 * assert.deepStrictEqual(SemigroupAll.concat(true, true), true)
 * assert.deepStrictEqual(SemigroupAll.concat(true, false), false)
 *
 * @category instances
 * @since 2.10.0
 */
var SemigroupAll = {
    concat: function(first, second) {
        return first && second;
    }
};
/**
 * `boolean` semigroup under disjunction.
 *
 * @example
 * import { SemigroupAny } from 'fp-ts/boolean'
 *
 * assert.deepStrictEqual(SemigroupAny.concat(true, true), true)
 * assert.deepStrictEqual(SemigroupAny.concat(true, false), true)
 * assert.deepStrictEqual(SemigroupAny.concat(false, false), false)
 *
 * @category instances
 * @since 2.10.0
 */
var SemigroupAny = {
    concat: function(first, second) {
        return first || second;
    }
};
/**
 * `boolean` monoid under conjunction.
 *
 * The `empty` value is `true`.
 *
 * @example
 * import { MonoidAll } from 'fp-ts/boolean'
 *
 * assert.deepStrictEqual(MonoidAll.concat(true, true), true)
 * assert.deepStrictEqual(MonoidAll.concat(true, false), false)
 *
 * @category instances
 * @since 2.10.0
 */
var MonoidAll = {
    concat: SemigroupAll.concat,
    empty: true
};
/**
 * `boolean` monoid under disjunction.
 *
 * The `empty` value is `false`.
 *
 * @example
 * import { MonoidAny } from 'fp-ts/boolean'
 *
 * assert.deepStrictEqual(MonoidAny.concat(true, true), true)
 * assert.deepStrictEqual(MonoidAny.concat(true, false), true)
 * assert.deepStrictEqual(MonoidAny.concat(false, false), false)
 *
 * @category instances
 * @since 2.10.0
 */
var MonoidAny = {
    concat: SemigroupAny.concat,
    empty: false
};

const firstRight = (candidate, defaultT, resolvers) => {
    const firstRightSemi = getSemigroup(first());
    const concatFirstRightSemi = concatAll$1(firstRightSemi)(left(defaultT));
    return pipe(
        concatFirstRightSemi(
            pipe(
                resolvers,
                map(
                    (r) => pipe(
                        candidate,
                        fromPredicate(r[0], () => defaultT),
                        map$1(r[1])
                    )
                )
            )
        ),
        fold(identity, identity)
    );
};
const equals = (E2) => (lhs) => (rhs) => E2.equals(lhs, rhs);
const concatApply = (m) => (fns) => (data) => pipe(fns, ap( of (data)), concatAll(m));
const and = concatApply(MonoidAll);
const or = concatApply(MonoidAny);
const tap = (f) => (data) => {
    f(data);
    return data;
};
const logWithTag = (tag, processor = identity) => (data) => console.log(tag, processor(data));
const stringifyWithTag = (tag) => (data) => console.log(tag, JSON.stringify(data, null, 2));
const log = (tag, processor = identity) => tap(logWithTag(tag, processor));
const deepLog = (tag) => tap(stringifyWithTag(tag));
const getMatches = (regex) => (str) => pipe(regex.exec(str), fromNullable);
const stringifyWithReplace = (replacer, space = 2) => (a) => tryCatch(() => {
    const s = JSON.stringify(a, replacer, space);
    if (typeof s !== "string") {
        throw new Error("Converting unsupported structure to JSON");
    }
    return s;
}, identity);

export {
    MonoidAny as M, and as a, concatApply as c, deepLog as d, equals as e, firstRight as f, getMatches as g, log as l, or as o, stringifyWithReplace as s, tap as t
};
//# sourceMappingURL=fp-utils-57808465.js.map