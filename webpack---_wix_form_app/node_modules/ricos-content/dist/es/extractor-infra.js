import {
    m as map,
    a as compact,
    b as fromPredicate
} from './Option-87dfe66c.js';
import {
    p as pipe
} from './ReadonlyNonEmptyArray-3599e877.js';
import {
    u as unfoldTree,
    f as fromTraversable,
    P as Prism,
    L as Lens,
    t as tree
} from './index-907c0cc3.js';
import './ReadonlyRecord-da7aaead.js';
import './string-04247af1.js';

const getExtractor = (nodesAccessor) => (root) => {
    class TraversalExtractor {
        constructor(traversal, tree2) {
            this.traversal = traversal;
            this.tree = tree2;
        }
        filter(predicate) {
            return new TraversalExtractor(
                this.traversal.composePrism(Prism.fromPredicate(predicate)),
                this.tree
            );
        }
        map(mapper) {
            return new TraversalExtractor(
                this.traversal.composeLens(new Lens(mapper, () => (dt) => dt)),
                this.tree
            );
        }
        chain(mapper) {
            return pipe(this.get(), map(mapper));
        }
        get() {
            return pipe(
                this.traversal.asFold().getAll(this.tree),
                map(fromPredicate(Boolean)),
                compact
            );
        }
    }
    const tree$1 = unfoldTree(root, (node) => [node, nodesAccessor(node)]);
    return new TraversalExtractor(fromTraversable(tree)(), tree$1);
};

export {
    getExtractor
};
//# sourceMappingURL=extractor-infra.js.map