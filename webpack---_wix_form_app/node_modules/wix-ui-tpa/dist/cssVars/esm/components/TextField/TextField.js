import * as React from 'react';
import {
    CoreInput
} from '../internal/WixUiCoreComponents/components/CoreInput';
import {
    st,
    classes
} from './TextField.st.css';
import {
    Check,
    Error,
    ChevronUpSmall,
    ChevronDownSmall,
} from '@wix/wix-ui-icons-common/on-stage';
import {
    ClearXSmall
} from '@wix/wix-ui-icons-common/on-stage/system';
import {
    Hidden,
    Visible
} from '@wix/wix-ui-icons-common';
import {
    IconButton,
    IconButtonSkins
} from '../IconButton';
import {
    Tooltip,
    TooltipSkin
} from '../Tooltip';
import {
    EMPTY,
    ERROR,
    SUCCESS,
    THEME,
    DATA_HOOKS
} from './dataKeys';
import {
    IconTooltip
} from '../IconTooltip';
import {
    ErrorMessageWrapper
} from '../internal/ErrorMessageWrapper';
import {
    TextFieldTheme,
    TextFieldLabelStyle,
} from './types';
import {
    getAriaDescribedBy
} from '../../common/a11y';
import uniqueId from '../../common/uniqueId';
import {
    Text
} from '../Text/Text';
export class TextField extends React.Component {
    constructor(props) {
        super(props);
        this._rootRef = React.createRef();
        this.state = {
            isErrorTooltipShown: false,
            isPasswordVisible: this.props.visible ? ? false,
            isFocused: false,
        };
        this.TextFieldRef = React.createRef();
        this.focus = () => {
            this.TextFieldRef.current.focus();
        };
        this.blur = () => {
            this.TextFieldRef.current.blur();
        };
        this.showErrorTooltip = () => {
            this._toggleTooltip(true);
        };
        this.hideErrorTooltip = () => {
            this._toggleTooltip(false);
        };
        this._getClearButton = (shouldAddClearButtonGap) => {
            const {
                clearButtonAriaLabel,
                clearButtonAriaLabelledby,
                onClear
            } = this.props;
            return (React.createElement("div", {
                    className: classes.clearButtonWrapper
                },
                React.createElement(IconButton, {
                    className: classes.clearButton,
                    "data-hook": DATA_HOOKS.CLEAR_BUTTON,
                    "aria-label": clearButtonAriaLabel,
                    "aria-labelledby": clearButtonAriaLabelledby,
                    skin: IconButtonSkins.Line,
                    onClick: onClear ? () => this.props.onClear() : undefined,
                    icon: React.createElement(ClearXSmall, null)
                }),
                shouldAddClearButtonGap && React.createElement("div", {
                    className: classes.clearButtonGap
                })));
        };
        this._getErrorSuffix = () => {
            const {
                isErrorTooltipShown
            } = this.state;
            const {
                errorMessage,
                errorTooltipPlacement,
                errorTooltipMaxWidth
            } = this.props;
            return (React.createElement(IconTooltip, {
                "data-hook": DATA_HOOKS.ERROR_ICON,
                message: errorMessage,
                icon: React.createElement(Error, {
                    className: classes.errorIcon
                }),
                tooltipId: this._errorMessageId,
                tooltipSkin: TooltipSkin.Error,
                showTooltip: isErrorTooltipShown,
                onClick: this._onErrorButtonClick,
                onClickOutside: this._onClickOutside,
                tooltipProps: {
                    placement: errorTooltipPlacement,
                    moveBy: {
                        x: 5,
                        y: 0
                    },
                    maxWidth: errorTooltipMaxWidth,
                }
            }));
        };
        this._getSuccessSuffix = () => {
            return (React.createElement(Check, {
                "data-hook": DATA_HOOKS.SUCCESS_ICON,
                className: classes.successIcon
            }));
        };
        this._getArrowsSuffix = () => {
            const triggerInputEvent = () => this.inputRef ? .dispatchEvent(new Event('input', {
                bubbles: true
            }));
            const stepUp = () => {
                this.inputRef ? .stepUp();
                triggerInputEvent();
            };
            const stepDown = () => {
                this.inputRef ? .stepDown();
                triggerInputEvent();
            };
            return (React.createElement("div", {
                    className: classes.arrowsSuffixWrapper,
                    "data-hook": DATA_HOOKS.ARROW_ICONS
                },
                React.createElement("button", {
                        className: classes.arrowBtn,
                        onClick: stepUp,
                        type: "button"
                    },
                    React.createElement(ChevronUpSmall, {
                        size: 16
                    })),
                React.createElement("button", {
                        className: classes.arrowBtn,
                        onClick: stepDown,
                        type: "button"
                    },
                    React.createElement(ChevronDownSmall, {
                        size: 16
                    }))));
        };
        this._togglePasswordVisibility = () => {
            const {
                isPasswordVisible
            } = this.state;
            this.setState({
                isPasswordVisible: !isPasswordVisible
            });
            this.props.onPasswordVisibilityChange ? .(isPasswordVisible ? 'visible' : 'hidden');
        };
        this._handleVisibilityIconPressed = (e) => {
            if (e.key === 'Enter') {
                this._togglePasswordVisibility();
            }
        };
        this._getShowHideIcon = () => {
            const {
                isPasswordVisible
            } = this.state;
            const {
                hidePasswordTooltipText,
                showPasswordTooltipText,
                disabled
            } = this.props;
            const tooltip = isPasswordVisible ?
                hidePasswordTooltipText ? ? 'Hide password' :
                showPasswordTooltipText ? ? 'Show password';
            const Icon = isPasswordVisible ? Hidden : Visible;
            const dataHook = isPasswordVisible ?
                DATA_HOOKS.HIDDEN_ICON :
                DATA_HOOKS.VISIBLE_ICON;
            return (React.createElement("div", {
                    className: classes.customSuffix
                },
                React.createElement(Tooltip, {
                        content: tooltip,
                        disabled: disabled
                    },
                    React.createElement(Icon, {
                        role: "button",
                        className: st(classes.passwordVisibilityButton, {
                            disabled
                        }),
                        "data-hook": dataHook,
                        tabIndex: 0,
                        "aria-label": tooltip,
                        onClick: !disabled && this._togglePasswordVisibility,
                        onKeyDown: !disabled && this._handleVisibilityIconPressed,
                        "aria-pressed": true
                    }))));
        };
        this._isNewErrorMessage = () => this.props.newErrorMessage || this._isPassword;
        this._getSuffix = () => {
            const {
                error,
                errorMessage,
                success,
                successIcon,
                suffix,
                withClearButton,
                value,
                disabled,
                type,
            } = this.props;
            const shouldShowCustomSuffix = !!suffix;
            const shouldShowPasswordSuffix = this._isPassword;
            const shouldShowErrorIcon = error && errorMessage && !this._isNewErrorMessage();
            const shouldShowSuccessIcon = successIcon && success;
            const shouldShowClearButton = withClearButton && value && !disabled;
            const shouldShowArrows = type === 'number';
            const shouldAddClearButtonGap = shouldShowCustomSuffix || shouldShowErrorIcon || shouldShowSuccessIcon;
            const hasSuffix = shouldShowCustomSuffix ||
                shouldShowPasswordSuffix ||
                shouldShowErrorIcon ||
                shouldShowSuccessIcon ||
                shouldShowClearButton ||
                shouldShowArrows;
            return hasSuffix ? (React.createElement("div", {
                    className: st(classes.suffixWrapper, {
                        arrows: shouldShowArrows,
                    })
                },
                shouldShowClearButton ?
                this._getClearButton(shouldAddClearButtonGap) :
                null,
                shouldShowErrorIcon ? this._getErrorSuffix() : null,
                shouldShowSuccessIcon ? this._getSuccessSuffix() : null,
                shouldShowArrows ? this._getArrowsSuffix() : null,
                shouldShowPasswordSuffix ? this._getShowHideIcon() : null,
                suffix ? (React.createElement("div", {
                    className: classes.customSuffix,
                    "data-hook": DATA_HOOKS.CUSTOM_SUFFIX
                }, suffix)) : null)) : null;
        };
        this._getPrefix = () => {
            const {
                prefix,
                prefixLabel
            } = this.props;
            return prefix ? (React.createElement("span", {
                    "data-hook": DATA_HOOKS.PREFIX,
                    className: classes.prefix
                },
                prefix,
                prefixLabel ? (React.createElement("span", {
                    id: this._prefixLabelId,
                    className: classes.prefixLabel,
                    "data-sr-only": "true",
                    "data-hook": DATA_HOOKS.PREFIX_LABEL
                }, prefixLabel)) : null)) : null;
        };
        this._floatingLabelInput = React.forwardRef((props, ref) => {
            const {
                label,
                value,
                theme,
                placeholder
            } = this.props;
            const hasFloatingLabelActive = !!value || this.state.isFocused;
            return (React.createElement("div", {
                    className: classes.floatingInput
                },
                React.createElement("div", {
                        className: classes.floatingLabelWrapper
                    },
                    React.createElement("label", {
                        "data-hook": DATA_HOOKS.FLOATING_LABEL,
                        htmlFor: this._inputId,
                        className: st(classes.label, {
                            theme,
                            style: TextFieldLabelStyle.Floating,
                        })
                    }, label),
                    "\u00A0"),
                React.createElement("input", { ...props,
                    ref: ref,
                    placeholder: hasFloatingLabelActive ? placeholder : null
                })));
        });
        this._toggleTooltip = (showTooltip) => {
            this.setState({
                isErrorTooltipShown: showTooltip
            });
        };
        this._onErrorButtonClick = () => {
            const {
                isErrorTooltipShown
            } = this.state;
            this._toggleTooltip(!isErrorTooltipShown);
        };
        this._onClickOutside = () => {
            if (this._rootRef.current &&
                !this._rootRef.current.contains(document.activeElement)) {
                this._toggleTooltip(false);
            }
        };
        this._onFocus = (e) => {
            const {
                onFocus
            } = this.props;
            if (onFocus) {
                onFocus(e);
            }
            if (!e.defaultPrevented &&
                this._rootRef.current &&
                this._rootRef.current.contains(document.activeElement)) {
                this._toggleTooltip(true);
            }
            this.setState({
                isFocused: true
            });
        };
        this._onBlur = (e) => {
            const {
                onBlur
            } = this.props;
            if (onBlur) {
                onBlur(e);
            }
            this.setState({
                isFocused: false
            });
        };
        this._getCharCount = () => {
            const {
                value,
                maxLength
            } = this.props;
            return (React.createElement("div", {
                    "data-hook": DATA_HOOKS.CHAR_COUNT,
                    className: classes.charCount
                },
                React.createElement("div", {
                    dir: "ltr"
                }, `${value.length}/${maxLength}`)));
        };
        this._isPassword = props.type === 'password';
        this._inputId = props.id ? ? uniqueId('label-for-id');
        this._errorMessageId = uniqueId('error-message');
        this._prefixLabelId = uniqueId('prefix-label');
    }
    render() {
        const {
            errorMessage,
            success,
            successIcon,
            error,
            dir,
            disabled,
            theme,
            suffix,
            prefix,
            prefixLabel,
            className,
            withClearButton,
            onClear,
            clearButtonAriaLabel,
            clearButtonAriaLabelledby,
            errorTooltipPlacement,
            label,
            labelStyle,
            maxLength,
            showCharCount,
            value,
            forceLabel,
            inputClassName,
            'aria-describedby': ariaDescribedByProp,
            helperText,
            inputRef,
            type,
            // Props that should not be passed down to CoreInput.
            newErrorMessage,
            onPasswordVisibilityChange,
            visible,
            ...restProps
        } = this.props;
        const dataObject = {
            [THEME]: theme,
            [SUCCESS]: success,
            [ERROR]: error,
            [EMPTY]: !value,
        };
        const Wrapper = this._isNewErrorMessage() ?
            ErrorMessageWrapper :
            React.Fragment;
        const hasPrefix = !!prefix;
        const hasSuffix = !!suffix;
        const hasErrorMessage = !!errorMessage;
        const hasFloatingLabel = labelStyle === TextFieldLabelStyle.Floating;
        const hasFloatingLabelActive = hasFloatingLabel && (!!value || this.state.isFocused);
        const stStates = {
            error,
            theme,
            success,
            disabled,
            hasPrefix,
            newErrorMessage: this._isNewErrorMessage(),
            hasSuffix,
            hasErrorMessage,
            hasFloatingLabel,
            hasFloatingLabelActive,
        };
        const ariaDescribedBy = getAriaDescribedBy([
            ariaDescribedByProp,
            errorMessage ? this._errorMessageId : '',
            prefixLabel ? this._prefixLabelId : '',
        ]);
        const inputType = this._isPassword ?
            this.state.isPasswordVisible ?
            'text' :
            'password' :
            type;
        return (React.createElement("div", {
                className: st(classes.root, stStates, className),
                dir: dir,
                ref: this._rootRef
            },
            React.createElement(Wrapper, { ...(this._isNewErrorMessage() && {
                        visible: error && !!errorMessage,
                        message: errorMessage,
                        messageId: this._errorMessageId,
                        suffixText: showCharCount && maxLength && this._getCharCount(),
                        className: st(classes.errorWrapper),
                    })
                },
                label && !hasFloatingLabel ? (React.createElement("label", {
                        "data-hook": DATA_HOOKS.LABEL,
                        htmlFor: this._inputId,
                        className: st(classes.label, {
                            theme
                        })
                    },
                    label,
                    this.props.required && React.createElement("span", null, " *"))) : (forceLabel && (React.createElement("div", {
                    className: classes.label,
                    "aria-hidden": "true",
                    "data-hook": DATA_HOOKS.LABEL_PLACEHOLDER
                }, "\u00A0"))),
                React.createElement(CoreInput, { ...dataObject,
                    className: st(classes.input, {
                        theme
                    }, helperText && classes.withHelperText),
                    inputClassName: `${inputClassName || ''} has-custom-focus`,
                    id: this._inputId,
                    "aria-describedby": ariaDescribedBy,
                    value: value,
                    maxLength: maxLength,
                    ref: this.TextFieldRef,
                    suffix: this._getSuffix(),
                    prefix: this._getPrefix(),
                    error: error,
                    "aria-invalid": error,
                    ...restProps,
                    type: inputType,
                    customInput: hasFloatingLabel && this._floatingLabelInput,
                    disabled: disabled,
                    onFocus: this._onFocus,
                    onBlur: this._onBlur,
                    inputRef: (input) => {
                        this.inputRef = input;
                        inputRef ? .(input);
                    }
                }),
                maxLength &&
                !(this._isNewErrorMessage() && error && errorMessage) &&
                showCharCount &&
                this._getCharCount()), !!helperText && (React.createElement(Text, {
                className: classes.helperText,
                "data-hook": DATA_HOOKS.HELPER_TEXT
            }, helperText))));
    }
}
TextField.displayName = 'TextField';
TextField.defaultProps = {
    success: false,
    successIcon: false,
    error: false,
    withClearButton: false,
    disabled: false,
    theme: TextFieldTheme.Box,
    errorTooltipPlacement: 'top-end',
    forceLabel: false,
    labelStyle: TextFieldLabelStyle.Regular,
};
//# sourceMappingURL=TextField.js.map