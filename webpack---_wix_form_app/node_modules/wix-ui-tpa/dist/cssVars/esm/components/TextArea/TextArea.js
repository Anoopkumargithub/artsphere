import * as React from 'react';
import classnames from 'classnames';
import {
    st,
    classes
} from './TextArea.st.css';
import {
    deprecationLog
} from '../../common/deprecationLog';
import {
    LABEL_DATA_HOOK,
    TEXT_AREA_DATA_HOOK,
    TEXT_AREA_ERROR_DATA_HOOK,
    CHAR_COUNTER_DATA_HOOK,
    ERROR_ICON_DATA_HOOK,
} from './dataHooks';
import {
    Error
} from '@wix/wix-ui-icons-common/on-stage';
import {
    TEXT_AREA_DISABLED,
    TEXT_AREA_ERROR,
    TEXT_AREA_SUCCESS,
    TEXT_AREA_THEME,
    TEXT_AREA_FOCUS,
} from './dataKeys';
import {
    TooltipSkin
} from '../Tooltip/types';
import {
    TPAComponentsConsumer,
    TPAComponentsContext,
} from '../../../../esm/components/TPAComponentsConfig';
import {
    IconTooltip
} from '../IconTooltip';
import {
    ErrorMessageWrapper
} from '../internal/ErrorMessageWrapper';
import {
    TextAreaTheme,
} from './types';
import {
    getAriaDescribedBy
} from '../../common/a11y';
import uniqueId from '../../common/uniqueId';
/** TextArea component */
export class TextArea extends React.Component {
    constructor(props) {
        super(props);
        this._rootRef = React.createRef();
        this.state = {
            focused: false,
            isErrorTooltipShown: false,
        };
        this._getErrorIconTooltip = () => {
            const {
                isErrorTooltipShown
            } = this.state;
            const {
                errorDescription,
                errorMessage,
                errorTooltipPlacement,
                errorTooltipMaxWidth,
            } = this.props;
            const message = errorDescription || errorMessage;
            return (React.createElement(IconTooltip, {
                "data-hook": ERROR_ICON_DATA_HOOK,
                className: st(classes.iconTooltip),
                message: message,
                icon: React.createElement(Error, {
                    className: classes.errorIcon
                }),
                tooltipId: this._errorMessageId,
                tooltipSkin: TooltipSkin.Error,
                showTooltip: isErrorTooltipShown,
                onClick: this._onErrorButtonClick,
                onBlur: this._onClickOutsideOrBlur,
                onClickOutside: this._onClickOutsideOrBlur,
                tooltipProps: {
                    placement: errorTooltipPlacement,
                    appendTo: 'scrollParent',
                    moveBy: {
                        x: 5,
                        y: 0
                    },
                    maxWidth: errorTooltipMaxWidth,
                }
            }));
        };
        this.showErrorTooltip = () => {
            this._toggleTooltip(true);
        };
        this.hideErrorTooltip = () => {
            this._toggleTooltip(false);
        };
        this._onFocus = (event) => {
            this.props.onFocus && this.props.onFocus(event);
            this.setState({
                focused: true
            });
            if (this._rootRef.current &&
                this._rootRef.current.contains(document.activeElement)) {
                this._toggleTooltip(true);
            }
        };
        this._toggleTooltip = (showTooltip) => {
            this.setState({
                isErrorTooltipShown: showTooltip
            });
        };
        this._onErrorButtonClick = () => {
            const {
                isErrorTooltipShown
            } = this.state;
            this._toggleTooltip(!isErrorTooltipShown);
        };
        this._onClickOutsideOrBlur = () => {
            if (this._rootRef.current &&
                !this._rootRef.current.contains(document.activeElement)) {
                this._toggleTooltip(false);
            }
        };
        this._onBlur = (event) => {
            this.props.onBlur && this.props.onBlur(event);
            this.setState({
                focused: false
            });
        };
        this._getCharCount = () => {
            const {
                value,
                maxLength
            } = this.props;
            return (React.createElement("div", {
                "data-hook": CHAR_COUNTER_DATA_HOOK,
                className: classes.charCount
            }, `${value.length}/${maxLength}`));
        };
        this.labelForId = uniqueId('label-for-id_');
        this._errorMessageId = uniqueId('error-message');
        if (this.props.errorDescription) {
            deprecationLog('TextArea', 'The prop "errorDescription" is deprecated and will be removed in a future version, please use the "errorMessage" prop instead.');
        }
    }
    _getDataAttributes() {
        const {
            disabled,
            success,
            theme,
            error
        } = this.props;
        const {
            focused
        } = this.state;
        return {
            [TEXT_AREA_DISABLED]: disabled,
            [TEXT_AREA_THEME]: theme,
            [TEXT_AREA_ERROR]: error,
            [TEXT_AREA_SUCCESS]: success,
            [TEXT_AREA_FOCUS]: focused,
        };
    }
    render() {
        const {
            value,
            theme,
            error,
            success,
            disabled,
            label,
            onChange,
            placeholder,
            errorDescription,
            errorMessage,
            autoFocus,
            className,
            maxLength,
            showCharCount,
            'aria-describedby': ariaDescribedByProp,
            newErrorMessage,
            withResize,
            required,
        } = this.props;
        const dataObject = this._getDataAttributes();
        const Wrapper = newErrorMessage ? ErrorMessageWrapper : React.Fragment;
        const showErrorIcon = error && (errorDescription || errorMessage) && !newErrorMessage;
        const message = errorDescription || errorMessage;
        const hasErrorMessage = !!message;
        const {
            mobile: isMobile
        } = this.context;
        const stStates = {
            error,
            theme,
            success,
            disabled,
            newErrorMessage,
            hasErrorMessage,
        };
        const hasFocusRing = !isMobile && this.state.focused;
        const ariaDescribedBy = getAriaDescribedBy([
            ariaDescribedByProp,
            message ? this._errorMessageId : '',
        ]);
        return (React.createElement(Wrapper, { ...(newErrorMessage && {
                    visible: error && hasErrorMessage,
                    message,
                    messageId: this._errorMessageId,
                    className: st(classes.root, stStates, className),
                    suffixText: showCharCount && maxLength && this._getCharCount(),
                })
            },
            React.createElement(TPAComponentsConsumer, null, ({
                rtl
            }) => {
                return (React.createElement("div", {
                        className: st(classes.root, {
                            error,
                            rtl,
                            errorMessage: !!message,
                            theme,
                            success,
                            disabled,
                        }, className),
                        ...dataObject,
                        "data-hook": this.props['data-hook'],
                        ref: this._rootRef
                    },
                    label && (React.createElement("label", {
                        htmlFor: this.props.id || this.labelForId,
                        "data-hook": LABEL_DATA_HOOK,
                        className: st(classes.label)
                    }, label)),
                    React.createElement("div", {
                            className: st(classes.textAreaWrapper, {
                                withResize,
                            }, classnames({
                                [classes.focused]: hasFocusRing
                            }))
                        },
                        React.createElement("textarea", {
                            value: value,
                            disabled: disabled,
                            onChange: (e) => {
                                if (!disabled) {
                                    onChange(e);
                                }
                            },
                            id: this.props.id || this.labelForId,
                            maxLength: maxLength,
                            autoFocus: autoFocus,
                            onFocus: this._onFocus,
                            onBlur: this._onBlur,
                            placeholder: placeholder,
                            className: classnames(classes.textArea, 'has-custom-focus'),
                            "data-hook": TEXT_AREA_DATA_HOOK,
                            "aria-label": this.props.ariaLabel,
                            "aria-describedby": ariaDescribedBy,
                            "aria-invalid": error,
                            required: required
                        }),
                        showErrorIcon && (React.createElement("div", {
                            "data-hook": TEXT_AREA_ERROR_DATA_HOOK,
                            className: classes.errorIconWrapper
                        }, this._getErrorIconTooltip()))),
                    maxLength &&
                    !(newErrorMessage && error && message) &&
                    showCharCount &&
                    this._getCharCount()));
            })));
    }
}
TextArea.contextType = TPAComponentsContext;
TextArea.displayName = 'TextArea';
TextArea.defaultProps = {
    error: false,
    success: false,
    disabled: false,
    placeholder: '',
    errorMessage: '',
    errorDescription: '',
    theme: TextAreaTheme.Box,
    showCharCount: false,
    errorTooltipPlacement: 'top-end',
    withResize: false,
    required: false,
};
//# sourceMappingURL=TextArea.js.map