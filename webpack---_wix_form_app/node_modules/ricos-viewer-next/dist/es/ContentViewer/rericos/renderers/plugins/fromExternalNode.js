import React from 'react';
import {
    convertStructToJson
} from 'ricos-content/libs/struct-converters';
import {
    Node_Type
} from 'ricos-schema';
import {
    g as getAlignmentClassName,
    a as getSizeClassName,
    b as getTextWrapClassName
} from '../../../../getClassNames-2d778f5a.js';
import {
    nodeViewContainer
} from './nodeViewContainer.js';
import 'lodash';
import 'classnames';
import 'ricos-context';
import '../../../components/ErrorBoundary.js';
import '../../utils/Anchorable.js';
import './ContainerElement.js';
import 'wix-rich-content-common';
import '../../utils/paywallSeo.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const isDraftEntityConfig = (data) => (data.width || data.alignment || data.textWrap) && (["content", "original", "fullWidth", "small"].includes(data.size) || ["center", "left", "right"].includes(data.alignment));
const toContainerData = (data) => __spreadValues(__spreadValues(__spreadValues({}, typeof data.size === "string" ? {
    width: {
        size: data.size.toUpperCase()
    }
} : {}), typeof data.alignment === "string" ? {
    alignment: data.alignment.toUpperCase()
} : {}), typeof data.textWrap !== "undefined" ? {
    textWrap: data.textWrap !== "nowrap"
} : {});
const getContainerData = (externalData) => {
    if (isDraftEntityConfig(externalData.config || {})) {
        return toContainerData(externalData.config);
    }
    return externalData.containerData;
};
const Plugin = ({
    type,
    context,
    node,
    nodeIndex,
    children,
    pluginComponent: {
        component: Component
    }
}) => {
    var _a;
    const settings = ((_a = context.config) == null ? void 0 : _a[type]) || {};
    const componentData = node.externalData && convertStructToJson(node.externalData) || {};
    const containerData = getContainerData(componentData) || {};
    const componentProps = __spreadProps(__spreadValues({
        type,
        componentData,
        settings,
        children
    }, context), {
        blockKey: node.id
    });
    const customClassNames = {
        alignment: getAlignmentClassName(containerData),
        size: getSizeClassName(containerData),
        textWrap: getTextWrapClassName(containerData)
    };
    return /* @__PURE__ */ React.createElement(nodeViewContainer, {
        node,
        nodeIndex,
        customClassNames
    }, /* @__PURE__ */ React.createElement(Component, __spreadValues({}, componentProps)));
};
const fromExternalNode = (args) => {
    return {
        [Node_Type.EXTERNAL]: ({
            node,
            nodeIndex
        }) => {
            return /* @__PURE__ */ React.createElement(Plugin, __spreadValues({
                key: node.id,
                node,
                nodeIndex
            }, args));
        }
    };
};

export {
    fromExternalNode
};
//# sourceMappingURL=fromExternalNode.js.map